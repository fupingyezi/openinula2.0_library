declare enum InulaNodeType {
    Comp = 0,
    For = 1,
    Cond = 2,
    Exp = 3,
    Hook = 4,
    Context = 5,
    Children = 6,
    Fragment = 7,
    Portal = 8,
    Suspense = 9
}

type Value = any;
type Props = Record<PropertyKey, Value>;
type Bits = number;
type UpdateState = (dirty: Bits) => void;
type UpdateProp = (propName: string, newValue: Value) => void;
type UpdateView = (dirty: Bits) => void;
type GetViewAndUpdater = () => [InulaBaseNode, UpdateView];
type Lifecycle = (node?: InulaBaseNode) => void;
type ScopedLifecycle = Lifecycle[];
type InulaBaseNode = {
    inulaType?: InulaNodeType;
    update?: Updater<any>;
    nodes?: InulaBaseNode[];
    parentEl?: HTMLElement;
};
type Updater<T> = (node: T) => void;
type Component<T = Props> = (props: T) => CompNode;

/**
 * @brief Create a createFragmentNode node, will be unwrapped when rendered
 * @returns
 */
declare const createFragmentNode: (...nodes: InulaBaseNode[]) => InulaBaseNode;

type ContextID = Symbol;
type Context = {
    id: ContextID;
    defaultValue?: Record<string, Value>;
};
declare class ContextNode implements InulaBaseNode {
    inulaType: InulaNodeType;
    owner: CompNode;
    nodes?: InulaBaseNode[];
    updater?: Updater<ContextNode>;
    contextId: ContextID;
    contexts: Record<string, Value>;
    consumers: CompNode[];
    constructor(contextId: ContextID, updater?: Updater<ContextNode>);
    init(): void;
    with(...children: InulaBaseNode[]): this;
    update(): void;
    cachedDependenciesMap?: Record<string, Value[]>;
    updateContext(contextName: string, valueFunc: () => Value, deps: Value[], reactBits: Bits): void;
}
declare const createContextNode: (context: Context, updater?: ((node: ContextNode) => void) | undefined) => ContextNode;
declare const createContext: (defaultValue?: Record<string, Value>) => {
    id: symbol;
    defaultValue: Record<string, any> | undefined;
};
declare const useContext: (context: Context, compNode?: CompNode) => any;

interface InulaHTMLNode extends HTMLElement, InulaBaseNode {
    prevStyle?: CSSStyleDeclaration;
    [key: `c$${string}`]: Value[];
    [key: `me$${string}`]: EventListener;
    [key: `de$${string}`]: EventListener;
    __$owner?: CompNode;
}
interface InulaHTMLTemplateNode extends InulaHTMLNode {
    nodesInserted: InulaBaseNode[];
    elementsRetrieved: (InulaHTMLNode | InulaTextNode)[];
}
interface HTMLAttrsObject {
    [key: string]: Value;
    style?: CSSStyleDeclaration;
    dataset?: {
        [key: string]: string;
    };
}
interface InulaTextNode extends Text, InulaBaseNode {
    __$owner?: CompNode;
    dirtyBits?: Bits;
    [key: `c$${string}`]: Value[];
}

declare class MutableContextNode {
    savedContextNodes: ContextNode[];
    parentEl?: InulaHTMLNode;
    owner: CompNode;
    /**
     * @brief Mutable node is a node that this._$nodes can be changed, things need to pay attention:
     *  1. The environment of the new nodes should be the same as the old nodes
     *  2. The new nodes should be added to the parentEl
     *  3. The old nodes should be removed from the parentEl
     * @param type
     */
    constructor();
    /**
     * @brief Initialize the new nodes, add parentEl to all nodes
     * @param nodes
     */
    initNewNodes(nodes: InulaBaseNode[]): void;
    /**
     * @brief Generate new nodes in the saved environment
     * @param newNodesFunc
     * @returns
     */
    newNodesInContext(newNodesFunc: () => InulaBaseNode[]): InulaBaseNode[];
    /**
     * @brief Remove nodes from parentEl and run willUnmount and didUnmount
     * @param nodes
     * @param removeEl Only remove outermost element
     */
    removeNodes(nodes: InulaBaseNode[], parentEl?: InulaHTMLNode): void;
    initUnmountStore(): void;
}

declare class MutableLifecycleNode extends MutableContextNode {
    willUnmountScopedStore?: (() => void)[];
    didUnmountScopedStore?: (() => void)[];
    constructor();
    setUnmountFuncs(): void;
    runWillUnmount: () => void;
    runDidUnmount: () => void;
    removeNodes(nodes: InulaBaseNode[]): void;
    newNodesInContext(newNodesFunc: () => InulaBaseNode[]): InulaBaseNode[];
}

declare class SuspenseNode extends MutableLifecycleNode implements InulaBaseNode {
    inulaType: InulaNodeType;
    didSuspend: boolean;
    promiseSet: Set<PromiseType<{
        default: Component;
    }>>;
    fallbackNode: InulaBaseNode;
    children: InulaBaseNode[];
    contextNode: ContextNode;
    nodes: InulaBaseNode[];
    constructor();
    with(children: InulaBaseNode[]): this;
    fallback(fallback: () => InulaBaseNode): this;
    clearPromise(promise: PromiseType<{
        default: Component;
    }>): void;
    handlePromise(promise: PromiseType<{
        default: Component;
    }>): void;
    toggle(): void;
    getCurrentContent(): InulaBaseNode[];
    render(): void;
    update(): void;
}
declare function createSuspenseNode(): SuspenseNode;
interface PromiseType<R> {
    then<U>(onFulfill: (value: R) => void | PromiseType<U> | U, onReject: (error: any) => void | PromiseType<U> | U): void | PromiseType<U>;
}
declare function lazy<T extends Component>(promiseConstructor: () => PromiseType<{
    default: T;
}>): (props: Record<string, any>) => InulaBaseNode;

declare function ErrorBoundary({ fallback, children, }: {
    fallback: (error: Error) => InulaBaseNode[];
    children: () => InulaBaseNode[];
}): CompNode;

/**
 * @brief Shortcut for document.createHTMLNode
 * @param tag
 * @returns InulaHTMLNode
 */
declare const createHTMLNode: (tag: string, update: Updater<InulaHTMLNode>, ...childrenNodes: InulaBaseNode[]) => InulaHTMLNode;
/**
 * @brief Set HTML property
 * @param node
 * @param key
 * @param valueFunc
 * @param dependencies
 * @param reactBits
 */
declare const setHTMLProp: (node: InulaHTMLNode, key: string, valueFunc: () => Value, dependencies: Value[], reactBits: Bits) => void;
/**
 * @brief Set style
 * @param node
 * @param newStyleFunc
 * @param dependencies
 * @param reactBits
 */
declare function setStyle(node: InulaHTMLNode, newStyleFunc: (() => CSSStyleDeclaration) | CSSStyleDeclaration, dependencies?: Value[], reactBits?: Bits): void;
/**
 * @brief Set dataset properties
 * @param node The HTML node to update
 * @param valueFunc Function that returns dataset key-value pairs
 * @param dependencies Values this dataset depends on
 * @param reactBits Bits indicating which properties should react to changes
 */
declare const setDataset: (node: InulaHTMLNode, valueFunc: () => Record<string, string>, dependencies: Value[], reactBits: Bits) => void;
/**
 * @brief Set multiple HTML properties at once
 * @param node The HTML node to update
 * @param valueFunc Function that returns HTML properties object
 * @param dependencies Values these properties depend on
 * @param reactBits Bits indicating which properties should react to changes
 */
declare const setHTMLProps: (node: InulaHTMLNode, valueFunc: () => HTMLAttrsObject, dependencies: Value[], reactBits: Bits) => void;
/**
 * @brief Set multiple HTML attributes at once
 * @param node The HTML node to update
 * @param valueFunc Function that returns HTML attributes object
 * @param dependencies Values these attributes depend on
 * @param reactBits Bits indicating which attributes should react to changes
 */
declare const setHTMLAttrs: (node: InulaHTMLNode, valueFunc: () => HTMLAttrsObject, dependencies: Value[], reactBits: Bits) => void;
/**
 * @brief Set single HTML attribute
 * @param node The HTML node to update
 * @param key
 * @param valueFunc Function that returns HTML attribute
 * @param dependencies Values these attributes depend on
 * @param reactBits Bits indicating which attributes should react to changes
 */
declare const setHTMLAttr: (node: InulaHTMLNode, key: string, valueFunc: (() => Value) | Value, dependencies: Value[], reactBits: Bits) => void;
/**
 * @brief Set an event handler on a node
 */
declare const setEvent: (node: InulaHTMLNode, key: string, value: EventListener) => void;
/**
 * @brief Delegate an event handler through event bubbling
 */
declare const delegateEvent: (node: InulaHTMLNode, key: string, valueFunc: () => EventListener, dependencies: Value[], reactBits: Bits) => void;
declare function setRef(node: InulaHTMLNode, refFn: () => void): void;

declare const createTextNode: (text: string, update: Updater<InulaTextNode>) => InulaTextNode;
declare const setText: (node: InulaTextNode, text: string, dependencies: Value[], reactBits: Bits) => void;

/**
 * @brief Insert any DLNode into an element, set the nodes and append the element to the element's children
 * @param el
 * @param node
 * @param position
 */
declare const insertNode: (el: InulaHTMLNode, node: InulaBaseNode, position: number) => void;
/**
 * @brief Check if the node should update
 * @param node
 * @param key
 * @param dependencies
 * @param reactBits
 * @returns
 */
declare const shouldUpdate: (node: InulaHTMLNode | InulaTextNode, key: string, dependencies: Value[], reactBits: Bits) => boolean;
declare const getElementByPosition: (element: HTMLElement, ...positions: number[]) => HTMLElement;

declare const createTemplate: (template: string) => HTMLElement;
declare const createTemplateNode: (template: HTMLElement, getUpdater: ((node: InulaHTMLTemplateNode) => Updater<InulaHTMLTemplateNode>) | null, ...nodesToInsert: [number, InulaBaseNode, ...number[]][]) => InulaHTMLTemplateNode;
declare const templateAddNodeToUpdate: (node: InulaHTMLTemplateNode, nodeToAdd: InulaHTMLNode | InulaTextNode) => void;
declare const templateGetElement: (templateNode: InulaHTMLTemplateNode, ...positions: number[]) => InulaHTMLNode;

interface PortalNode extends InulaBaseNode {
    inulaType: InulaNodeType.Portal;
    nodes: InulaBaseNode[];
    target: InulaHTMLNode;
}
declare function createPortal(props: {
    target?: HTMLElement;
}, ...children: InulaBaseNode[]): PortalNode;
declare function Portal(props: {
    target?: HTMLElement;
    children: InulaBaseNode[];
}): void;

declare class HookNode extends ReactiveNode {
    value?: () => Value;
    triggerUpdate?: () => void;
    constructor();
    wave(_: Value, dirty: Bits): void;
    propDirtyBits: number;
    updateProp(propName: string, valueFunc: () => Value, dependencies: Value[], reactBits: Bits): void;
    init(value: () => Value, dependencies: () => Value[], reactBits: Bits): this;
}
declare const hookBuilder: () => HookNode;

declare function getCurrentCompNode(): CompNode;
declare function enterCompNode(compNode: CompNode): void;
declare function leaveCompNode(): void;
type DerivedStateComputation = [() => Value, () => Value[], Bits, string];
type HookComputation = [(dirty: Bits) => void];
declare abstract class ReactiveNode {
    cachedDependenciesMap?: Record<string, Value[]>;
    computations?: Array<DerivedStateComputation | HookComputation>;
    derivedCount?: number;
    owner?: CompNode;
    abstract wave(_: Value, dirty: Bits): void;
    constructor();
    deriveState(updateDerivedFunc: () => Value, dependenciesFunc: () => Value[], reactBits: Bits): void;
    watch(updateDerivedFunc: () => Value, dependenciesFunc: () => Value[], reactBits: Bits): void;
    updateState(dirty: Bits): void;
    updatePropMap?: Record<string, [(value: Value) => void, Bits]>;
    addProp(propName: string, updatePropFunc: (value: Value) => void, waveBits: Bits): void;
    executePropUpdate(updatePropMap: Record<string, [(value: Value) => void, Bits]>, propName: string, valueFunc: () => Value): void;
    updateContextMap?: Record<string, [ContextID, (value: Value) => void, Bits]>;
    addContext(context: Context, contextName: string, updateContextFunc: (value: Value) => void, waveBits: Bits): void;
    updateContext(contextId: ContextID, contextName: string, value: Value): void;
    useHook(hookNode: HookNode, emit: (value: Value) => void, hookUpdater: (hookNode: HookNode) => void): void;
    didMount(fn: Lifecycle): void;
    willUnmount(fn: Lifecycle): void;
    didUnmount(fn: Lifecycle): void;
}
/**
 * @brief Component Node
 * @description
 * ---- Extract CompNode as a class especially for function 'updateDerived',
 *      because if we assign a default function to an object,
 *      it'll be counted in memory usage for each object.
 *      But if we assign a function to a class, it'll be counted only once.
 * ---- Also, for some must-use functions, we can assign them to the class prototype.
 *      Other helper functions will be coded as separate functions with
 *      a CompNode instance as the first parameter.
 * ---- Updating:
 *     - updateState: parameter is an dirty
 *        because we need to maintain the order of the state updates
 *     - updateView: parameter is a merged dirty
 *        because we need to update the view only once in the next microtask
 */
declare class CompNode extends ReactiveNode implements InulaBaseNode {
    inulaType: InulaNodeType;
    nodes?: InulaBaseNode[];
    updater?: Updater<CompNode>;
    subComponents?: CompNode[];
    slices?: InulaBaseNode[];
    unmounted: boolean;
    setUnmounted: () => void;
    constructor(parentComponents: CompNode[]);
    updateProp(propName: string, valueFunc: () => Value, dependencies: Value[], reactBits: Bits): void;
    wave(_: Value, dirty: Bits): void;
    dirtyBits?: Bits;
    /**
     * @brief Update view asynchronously
     * @param dirty
     * @returns
     */
    updateViewAsync(dirty: Bits): void;
    prepare(): this;
    init(node: InulaBaseNode): this;
    update(): void;
}
/**
 * @brief Create a component node
 * @returns
 */
declare const compBuilder: (...parentComponents: CompNode[]) => CompNode;
declare const createCompNode: (compFn: (props: Record<string, Value>) => CompNode, props: Record<string, Value>, updater: Updater<CompNode> | null) => CompNode;
/**
 * Handle children nodes, like:
 * <Button><Child /></Button>
 * will be transformed to
 * <Button>{createChildren(() => <Child />)}</Button>
 *
 * We need bind the children nodes to the current compNode,
 * so that the children nodes can be updated when the compNode is updated.
 * @param nodesFn
 * @param compNode
 * @returns
 */
declare function createChildren(nodesFn: () => InulaBaseNode[], compNode: CompNode): {
    (): InulaBaseNode[];
    $$isChildren: boolean;
};

/**
 * @brief Render the component node to the container
 * @param compNode
 * @param container
 */
declare const render: (compNode: CompNode, container: HTMLElement) => void;

declare class ConditionalNode extends MutableLifecycleNode implements InulaBaseNode {
    inulaType: InulaNodeType;
    nodes?: InulaBaseNode[];
    currentBranch: number;
    updater: (node: ConditionalNode) => InulaBaseNode[];
    reactBits: Bits;
    constructor(updater: (node: ConditionalNode) => InulaBaseNode[], reactBits: Bits);
    conditionCacheMap?: Record<string, [boolean, Value[]]>;
    branch(branchNum: number): boolean;
    cachedCondition(branchNum: number, valueFunc: () => Value, dependencies: Value[]): any;
    update(): void;
}
declare const createConditionalNode: (updater: (node: ConditionalNode) => InulaBaseNode[], reactBits: Bits) => ConditionalNode;

type ForNodeFunc = (node: ForNode, updateItemFuncArr: UpdateItemFunc[], item: Value, key: Value, idx: number) => InulaBaseNode[];
type UpdateItemFunc = (item: Value, idx: number) => void;
declare class ForNode extends MutableContextNode implements InulaBaseNode {
    inulaType: InulaNodeType;
    dataReactBits: Bits;
    nodesMap: Map<any, any>;
    nodeFunc: ForNodeFunc;
    dataFunc: () => Value[];
    data: any[];
    keysFunc: (() => Value[]) | null;
    keys?: Value[];
    /**
     * @brief Getter for nodes
     */
    cachedNodes?: InulaBaseNode[];
    nodesDirty: boolean;
    get nodes(): any[] | undefined;
    setNodesMap(key: Value, nodes: InulaBaseNode[]): void;
    /**
     * @brief Constructor, For type
     * @param data
     * @param nodeFunc
     * @param keys
     */
    constructor(dataFunc: () => Value[], keysFunc: null | (() => Value[]), nodeFunc: ForNodeFunc, dataReactBits: Bits);
    updateItemFuncArr: UpdateItemFunc[];
    /**
     * @brief Update the view related to one item in the data
     * @param nodes
     * @param item
     */
    updateItem(idx: number, data: Value[]): void;
    updateItems(): void;
    notInitialized?: boolean | undefined;
    /**
     * @brief Non-data update function
     * @param changed
     */
    update(): void;
    /**
     * @brief Array-related update function
     * @param newData
     * @param newKeys
     */
    updateArray(): void;
    /**
     * @brief Shortcut to generate new nodes with idx and key
     */
    getNewNodes(idx: number, key: Value, data: Value[], updateItemFuncArr?: UpdateItemFunc[]): InulaBaseNode[];
    willUnmountMap: Map<any, any>;
    didUnmountMap: Map<any, any>;
    /**
     * @brief Set the unmount map by getting the last unmount map from the global store
     * @param key
     */
    setUnmountMap(key: Value): void;
    /**
     * @brief Run all the unmount functions and clear the unmount map
     */
    runAllWillUnmount(): void;
    /**
     * @brief Run all the unmount functions and clear the unmount map
     */
    runAllDidUnmount(): void;
    /**
     * @brief Run the unmount functions of the given key
     * @param key
     */
    runWillUnmount(key: Value): void;
    /**
     * @brief Run the unmount functions of the given key
     */
    runDidUnmount(key: Value): void;
    /**
     * @brief Remove nodes from parentEl and run willUnmount and didUnmount
     * @param nodes
     * @param key
     */
    removeNodesInLifeCycle(nodes: InulaBaseNode[], key: Value): void;
    /**
     * @brief Update the nodes without keys
     * @param newData
     */
    updateWithOutKey(): void;
    /**
     * @brief Update the nodes with keys
     * @param newData
     * @param newKeys
     */
    updateWithKey(): void;
}
declare const createForNode: (dataFunc: () => Value[], keysFunc: null | (() => Value[]), nodeFunc: ForNodeFunc, dataReactBits: Bits) => ForNode;

declare class ExpNode extends MutableLifecycleNode implements InulaBaseNode {
    inulaType: InulaNodeType;
    nodes?: InulaBaseNode[];
    updater: () => Value;
    reactBits: Bits;
    dependenciesFunc: () => Value[];
    cachedDeps?: Value[];
    constructor(updater: () => Value, dependenciesFunc: () => Value[], reactBits: Bits);
    update(): void;
    getExpressionResult(): any;
}
declare const createExpNode: (updater: () => Value, dependenciesFunc: () => Value[], reactBits: Bits) => ExpNode;

/**
 * @brief Get all DOM elements of the first level of the node
 * @param node The node to get elements from
 * @returns Array of HTMLElement or Text nodes
 */
declare const getDOMElements: (node: InulaBaseNode) => Array<HTMLElement | Text>;
declare function createElement(tagName: string): HTMLElement;
/**
 * @brief Get all DOM elements of the first level of an array of nodes
 * @param nodes Array of nodes to get elements from
 * @returns Array of HTMLElement or Text nodes
 */
declare const toDOMElements: (nodes: InulaBaseNode[]) => Array<HTMLElement | Text>;
/**
 * @brief Loop through all the shallow DOM elements of the nodes and run the callback function
 * @param nodes Array of nodes to loop through
 * @param runFunc Callback function to run on each element
 */
declare const loopShallowElements: (nodes: InulaBaseNode[], runFunc: (el: HTMLElement | Text) => void) => void;
/**
 * @brief Add parent element reference to all nodes recursively until reaching DOM nodes
 * @param nodes Array of nodes to add parent to
 * @param parentEl Parent HTMLElement to set
 */
declare const addParentElement: (nodes: Array<InulaBaseNode>, parentEl: HTMLElement) => void;
/**
 * @brief Get the flattened index position of a node within an array of nodes
 * @param nodes Array of nodes to search through
 * @param stopNode Optional node to stop counting at
 * @returns Index position of the stop node or total count of DOM nodes
 */
declare const getFlowIndexFromNodes: (nodes: InulaBaseNode[], stopNode?: InulaBaseNode) => number;
/**
 * @brief Insert nodes before a sibling or append them to parent element
 * @param nodes Array of nodes to insert/append
 * @param parentEl Parent element to insert into
 * @param nextSibling Optional next sibling node
 * @returns Number of nodes inserted
 */
declare const appendNodesWithSibling: (nodes: Array<InulaBaseNode>, parentEl: HTMLElement, nextSibling?: Node) => number;
/**
 * @brief Insert nodes at a specific index in parent element
 * @param nodes Array of nodes to insert
 * @param parentEl Parent element to insert into
 * @param index Position to insert at
 * @param length Optional pre-calculated length of parent's children
 * @returns Number of nodes inserted
 */
declare const appendNodesWithIndex: (nodes: InulaBaseNode[], parentEl: HTMLElement, index: number, length?: number) => number;
/**
 * @brief Insert nodes before a reference node
 * @param nodes Array of nodes to insert
 * @param parentEl Parent element to insert into
 * @param nextSibling Reference node to insert before
 * @returns Number of nodes inserted
 */
declare const insertNodesBefore: (nodes: InulaBaseNode[], parentEl: HTMLElement, nextSibling: Node) => number;
/**
 * @brief Append nodes to the end of a parent element
 * @param nodes Array of nodes to append
 * @param parentEl Parent element to append to
 * @returns Number of nodes appended
 */
declare const appendNodes: (nodes: InulaBaseNode[], parentEl: HTMLElement) => number;
/**
 * @brief Check if two arrays have identical values
 * @param arr1 First array to compare
 * @param arr2 Second array to compare
 * @returns True if arrays are equal, false otherwise
 */
declare const arrayEqual: (arr1: Value[], arr2: Value[]) => boolean;
/**
 * @brief Check if dependencies have changed from previous values
 * @param deps Current dependency values
 * @param prevDeps Previous dependency values
 * @returns True if dependencies are cached (unchanged), false otherwise
 */
declare const cached: (deps: Value[], prevDeps?: Value[]) => boolean;
declare const InitDirtyBitsMask = 4294967295;
/**
 * @brief Update a node and all its children with dirty bits
 * @param node Node to update
 * @param dirtyBits Dirty bits indicating what needs updating
 */
declare const update: (node: InulaBaseNode) => void;
declare const willReact: (dirtyBits: Bits, reactBits: Bits) => number | true;
declare const init: (nodes: InulaBaseNode[]) => void;
declare function withDefault(value: any, defaultValue: any): any;

declare function watch(effect: () => void): void;
declare function didMount(effect: () => void): void;
declare function willUnmount(effect: () => void): void;
declare function didUnmount(effect: () => void): void;

export { Bits, CompNode, Component, Context, ContextID, ContextNode, ErrorBoundary, GetViewAndUpdater, HTMLAttrsObject, HookNode, InitDirtyBitsMask, InulaBaseNode, InulaHTMLNode, InulaHTMLTemplateNode, InulaTextNode, Lifecycle, Portal, PortalNode, PromiseType, Props, ReactiveNode, ScopedLifecycle, UpdateProp, UpdateState, UpdateView, Updater, Value, addParentElement, appendNodes, appendNodesWithIndex, appendNodesWithSibling, arrayEqual, cached, compBuilder, createChildren, createCompNode, createConditionalNode, createContext, createContextNode, createElement, createExpNode, createForNode, createFragmentNode, createHTMLNode, createPortal, createSuspenseNode, createTemplate, createTemplateNode, createTextNode, delegateEvent, didMount, didUnmount, enterCompNode, getCurrentCompNode, getDOMElements, getElementByPosition, getFlowIndexFromNodes, hookBuilder, init, insertNode, insertNodesBefore, lazy, leaveCompNode, loopShallowElements, render, setDataset, setEvent, setHTMLAttr, setHTMLAttrs, setHTMLProp, setHTMLProps, setRef, setStyle, setText, shouldUpdate, templateAddNodeToUpdate, templateGetElement, toDOMElements, update, useContext, watch, willReact, willUnmount, withDefault };
