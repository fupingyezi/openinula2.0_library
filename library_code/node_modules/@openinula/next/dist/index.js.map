{"version":3,"sources":["../src/store.ts","../src/lifecycle.ts","../src/scheduler.ts","../src/Nodes/utils.ts","../src/Nodes/CompNode/node.ts","../src/Nodes/HTMLNode/utils.ts","../src/Nodes/HTMLNode/html.ts","../src/Nodes/HTMLNode/text.ts","../src/Nodes/HTMLNode/template.ts","../src/render.ts","../src/Nodes/UtilNodes/fragment.ts","../src/Nodes/UtilNodes/context.ts","../src/Nodes/MutableNodes/context.ts","../src/Nodes/MutableNodes/lifecycle.ts","../src/Nodes/MutableNodes/Suspense.ts","../src/Nodes/UtilNodes/ErrorBoundary.ts","../src/Nodes/UtilNodes/Portal.ts","../src/Nodes/HookNode/index.tsx","../src/Nodes/MutableNodes/conditional.ts","../src/Nodes/MutableNodes/for.ts","../src/Nodes/MutableNodes/expression.ts","../src/Nodes/macros.ts"],"sourcesContent":["// import { Store } from \"@inula/store\"\r\nconst Store: any = {};\r\n\r\nif (!('global' in Store)) {\r\n  if (globalThis) {\r\n    Store.global = globalThis;\r\n  } else {\r\n    Store.global = {};\r\n  }\r\n}\r\n\r\nif (!('document' in Store)) {\r\n  if (typeof document !== 'undefined') {\r\n    Store.document = document;\r\n  }\r\n}\r\n\r\nexport const InulaStore: {\r\n  global: Record<string, any>;\r\n  document: Document;\r\n  delegatedEvents: Set<string>;\r\n} = { ...Store, delegatedEvents: new Set() };\r\n\r\nexport function setGlobal(globalObj: Record<string, any>) {\r\n  InulaStore.global = globalObj;\r\n}\r\n\r\nexport function setDocument(customDocument: Document) {\r\n  InulaStore.document = customDocument;\r\n}\r\n","import { InulaStore } from './store';\r\nimport { Lifecycle } from './types';\r\n\r\n// ---- Define lifecycle stores. We initialize them as undefined to save memory.\r\n// ---- InulaStore.global.DidMountStore is a store for functions that will be executed when\r\n//      1. The component is mounted to the DOM\r\n//      2. New mutable components are mounted to the DOM\r\n//      So there's no need to store it in a scoped store.\r\n// ---- InulaStore.global.DidMountStore: Lifecycle[] | undefined;\r\n\r\n// ---- WillUnmountStore and DidUnmountStore are scoped stores for functions that will be executed when\r\n//      1. The component is unmounted from the DOM\r\n//      2. Old mutable components are unmounted from the DOM\r\n//      Since we don't know when the component will be unmounted, we need to store it in a scoped store.\r\n// ---- InulaStore.global.WillUnmountScopedStore: Lifecycle[][];\r\n// ---- InulaStore.global.DidUnmountScopedStore: Lifecycle[][];\r\n\r\n// ---- Add lifecycle functions to the stores\r\n/**\r\n * @brief Add a function to the DidMount store\r\n * @param func\r\n */\r\nexport const addDidMount = (func: Lifecycle) => {\r\n  if (!InulaStore.global.DidMountStore) InulaStore.global.DidMountStore = [];\r\n  InulaStore.global.DidMountStore.push(func);\r\n};\r\n\r\n/**\r\n * @brief Add a function to the latest WillUnmount store\r\n * @param func\r\n */\r\nexport const addWillUnmount = (func: Lifecycle) => {\r\n  if (!InulaStore.global.WillUnmountScopedStore) InulaStore.global.WillUnmountScopedStore = [];\r\n  const currentStore = InulaStore.global.WillUnmountScopedStore[InulaStore.global.WillUnmountScopedStore.length - 1];\r\n  if (!currentStore) return;\r\n  currentStore.push(func);\r\n};\r\n\r\n/**\r\n * @brief Add a function to the latest DidUnmount store\r\n * @param func\r\n */\r\nexport const addDidUnmount = (func: Lifecycle) => {\r\n  if (!InulaStore.global.DidUnmountScopedStore) InulaStore.global.DidUnmountScopedStore = [];\r\n  const currentStore = InulaStore.global.DidUnmountScopedStore[InulaStore.global.DidUnmountScopedStore.length - 1];\r\n  if (!currentStore) return;\r\n  currentStore.push(func);\r\n};\r\n\r\n// ---- Run lifecycle functions\r\n/**\r\n * @brief Run didMount functions in the reverse order\r\n */\r\nexport const runDidMount = () => {\r\n  const didMountStore = InulaStore.global.DidMountStore;\r\n  if (!didMountStore || didMountStore.length === 0) return;\r\n  // ---- Run from the last index to the first index\r\n  // ---- Init order: parent -> child\r\n  //      DidMount order: child -> parent\r\n  for (let i = didMountStore.length - 1; i >= 0; i--) {\r\n    didMountStore[i]();\r\n  }\r\n  // ---- One cycle is done. Clear the store.\r\n  InulaStore.global.DidMountStore = undefined;\r\n};\r\n\r\n/**\r\n * @brief Create a new unmount scope by pushing an empty array to the scoped stores\r\n */\r\nexport const startUnmountScope = () => {\r\n  InulaStore.global.WillUnmountScopedStore.push([]);\r\n  InulaStore.global.DidUnmountScopedStore.push([]);\r\n};\r\n\r\n/**\r\n * @brief End the unmount scope by popping the last array from the scoped stores\r\n * @returns\r\n */\r\nexport const endUnmountScope = () => {\r\n  return [InulaStore.global.WillUnmountScopedStore.pop(), InulaStore.global.DidUnmountScopedStore.pop()];\r\n};\r\n","/*\r\n * Copyright (c) 2024 Huawei Technologies Co.,Ltd.\r\n *\r\n * openInula is licensed under Mulan PSL v2.\r\n * You can use this software according to the terms and conditions of the Mulan PSL v2.\r\n * You may obtain a copy of Mulan PSL v2 at:\r\n *\r\n *          http://license.coscl.org.cn/MulanPSL2\r\n *\r\n * THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND,\r\n * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,\r\n * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\r\n * See the Mulan PSL v2 for more details.\r\n */\r\n\r\nconst p = Promise.resolve();\r\n\r\n/**\r\n * Schedule a task to run in the next microtask.\r\n */\r\nexport function schedule(task: () => void) {\r\n  p.then(task);\r\n}\r\n","import { InulaNodeType } from '../consts';\r\nimport { Bits, InulaBaseNode, Value } from '../types';\r\nimport { InulaHTMLNode } from './HTMLNode/types';\r\n\r\n/**\r\n * @brief Get all DOM elements of the first level of the node\r\n * @param node The node to get elements from\r\n * @returns Array of HTMLElement or Text nodes\r\n */\r\nexport const getDOMElements = (node: InulaBaseNode): Array<HTMLElement | Text> => {\r\n  return toDOMElements(node.nodes ?? []);\r\n};\r\n\r\n// --- Imperative template\r\nexport function createElement(tagName: string) {\r\n  return document.createElement(tagName);\r\n}\r\n/**\r\n * @brief Get all DOM elements of the first level of an array of nodes\r\n * @param nodes Array of nodes to get elements from\r\n * @returns Array of HTMLElement or Text nodes\r\n */\r\nexport const toDOMElements = (nodes: InulaBaseNode[]): Array<HTMLElement | Text> => {\r\n  const elements: Array<HTMLElement | Text> = [];\r\n  loopShallowElements(nodes, el => {\r\n    elements.push(el);\r\n  });\r\n  return elements;\r\n};\r\n\r\n/**\r\n * @brief Loop through all the shallow DOM elements of the nodes and run the callback function\r\n * @param nodes Array of nodes to loop through\r\n * @param runFunc Callback function to run on each element\r\n */\r\nexport const loopShallowElements = (nodes: InulaBaseNode[], runFunc: (el: HTMLElement | Text) => void) => {\r\n  const stack: Array<InulaBaseNode> = [...nodes].reverse();\r\n  while (stack.length > 0) {\r\n    const node = stack.pop()!;\r\n    if (node == null) continue;\r\n    if (node instanceof HTMLElement || node instanceof Text) {\r\n      runFunc(node as InulaHTMLNode | Text);\r\n    } else if (node.nodes && node.inulaType !== InulaNodeType.Portal) {\r\n      stack.push(...[...node.nodes].reverse());\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * @brief Add parent element reference to all nodes recursively until reaching DOM nodes\r\n * @param nodes Array of nodes to add parent to\r\n * @param parentEl Parent HTMLElement to set\r\n */\r\nexport const addParentElement = (nodes: Array<InulaBaseNode>, parentEl: HTMLElement) => {\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = nodes[i];\r\n    if ('inulaType' in node) {\r\n      node.parentEl = parentEl;\r\n      // ---- Recursively add parentEl to all non-html nodes\r\n      //      because they have the same parentEl\r\n      node.nodes && addParentElement(node.nodes, parentEl);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * @brief Get the flattened index position of a node within an array of nodes\r\n * @param nodes Array of nodes to search through\r\n * @param stopNode Optional node to stop counting at\r\n * @returns Index position of the stop node or total count of DOM nodes\r\n */\r\nexport const getFlowIndexFromNodes = (nodes: InulaBaseNode[], stopNode?: InulaBaseNode) => {\r\n  let index = 0;\r\n  const stack: InulaBaseNode[] = [...nodes].reverse();\r\n  while (stack.length > 0) {\r\n    const node = stack.pop()!;\r\n    if (node === stopNode) break;\r\n    if ('inulaType' in node) {\r\n      node.nodes && stack.push(...[...node.nodes].reverse());\r\n    } else {\r\n      index++;\r\n    }\r\n  }\r\n  return index;\r\n};\r\n\r\n/**\r\n * @brief Insert nodes before a sibling or append them to parent element\r\n * @param nodes Array of nodes to insert/append\r\n * @param parentEl Parent element to insert into\r\n * @param nextSibling Optional next sibling node\r\n * @returns Number of nodes inserted\r\n */\r\nexport const appendNodesWithSibling = (nodes: Array<InulaBaseNode>, parentEl: HTMLElement, nextSibling?: Node) => {\r\n  if (nextSibling) return insertNodesBefore(nodes, parentEl, nextSibling);\r\n  return appendNodes(nodes, parentEl);\r\n};\r\n\r\n/**\r\n * @brief Insert nodes at a specific index in parent element\r\n * @param nodes Array of nodes to insert\r\n * @param parentEl Parent element to insert into\r\n * @param index Position to insert at\r\n * @param length Optional pre-calculated length of parent's children\r\n * @returns Number of nodes inserted\r\n */\r\nexport const appendNodesWithIndex = (nodes: InulaBaseNode[], parentEl: HTMLElement, index: number, length?: number) => {\r\n  // ---- Calling parentEl.childNodes.length is expensive so we'd better pre-calculate it and pass it in\r\n  length = length ?? parentEl.childNodes.length;\r\n  if (length !== index) return insertNodesBefore(nodes, parentEl, parentEl.childNodes[index]);\r\n  return appendNodes(nodes, parentEl);\r\n};\r\n\r\n/**\r\n * @brief Insert nodes before a reference node\r\n * @param nodes Array of nodes to insert\r\n * @param parentEl Parent element to insert into\r\n * @param nextSibling Reference node to insert before\r\n * @returns Number of nodes inserted\r\n */\r\nexport const insertNodesBefore = (nodes: InulaBaseNode[], parentEl: HTMLElement, nextSibling: Node) => {\r\n  let count = 0;\r\n  loopShallowElements(nodes, el => {\r\n    parentEl.insertBefore(el, nextSibling);\r\n    count++;\r\n  });\r\n  return count;\r\n};\r\n\r\n/**\r\n * @brief Append nodes to the end of a parent element\r\n * @param nodes Array of nodes to append\r\n * @param parentEl Parent element to append to\r\n * @returns Number of nodes appended\r\n */\r\nexport const appendNodes = (nodes: InulaBaseNode[], parentEl: HTMLElement) => {\r\n  let count = 0;\r\n  loopShallowElements(nodes, el => {\r\n    parentEl.appendChild(el);\r\n    count++;\r\n  });\r\n  return count;\r\n};\r\n\r\n/**\r\n * @brief Check if two arrays have identical values\r\n * @param arr1 First array to compare\r\n * @param arr2 Second array to compare\r\n * @returns True if arrays are equal, false otherwise\r\n */\r\nexport const arrayEqual = (arr1: Value[], arr2: Value[]) => {\r\n  if (arr1.length !== arr2.length) return false;\r\n  return arr1.every((item, idx) => item === arr2[idx]);\r\n};\r\n\r\n/**\r\n * @brief Check if dependencies have changed from previous values\r\n * @param deps Current dependency values\r\n * @param prevDeps Previous dependency values\r\n * @returns True if dependencies are cached (unchanged), false otherwise\r\n */\r\nexport const cached = (deps: Value[], prevDeps?: Value[]) => {\r\n  if (prevDeps && prevDeps.length === 0) return false;\r\n  if (!prevDeps || deps.length !== prevDeps.length) return false;\r\n  // ---- Check if all deps are the same\r\n  //      if any dep is an object, we can't compare it with the previous one\r\n  //      because the reference is the same but the content may be different\r\n  // ---- Q: Why not use a deep comparison?\r\n  //      A: Because it's slow compared to regarding the cache as invalid\r\n  return deps.every((dep, i) => !(dep instanceof Object) && prevDeps[i] === dep);\r\n};\r\n\r\n// ---- All ones\r\nexport const InitDirtyBitsMask = 0xffffffff;\r\n\r\n/**\r\n * @brief Update a node and all its children with dirty bits\r\n * @param node Node to update\r\n * @param dirtyBits Dirty bits indicating what needs updating\r\n */\r\nexport const update = (node: InulaBaseNode) => {\r\n  node.update?.(node);\r\n};\r\n\r\nexport const willReact = (dirtyBits: Bits, reactBits: Bits) => {\r\n  // ---- 1. reactBits & dirtyBits means the node will react to the change\r\n  //      2. reactBits === 0 means it's a one time update, will be blocked by cached()\r\n  return reactBits === 0 || reactBits & dirtyBits;\r\n};\r\n\r\nexport const init = (nodes: InulaBaseNode[]) => {\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    update(nodes[i]);\r\n  }\r\n};\r\n\r\nexport function withDefault(value: any, defaultValue: any) {\r\n  return value === undefined ? defaultValue : value;\r\n}\r\n","import { Bits, Lifecycle, Value, Updater, InulaBaseNode } from '../../types';\r\nimport { InulaNodeType } from '../../consts';\r\nimport { addDidMount, addDidUnmount, addWillUnmount } from '../../lifecycle';\r\nimport { schedule } from '../../scheduler';\r\nimport { cached, InitDirtyBitsMask, update } from '../utils';\r\nimport { Context, ContextID } from '../UtilNodes';\r\nimport { HookNode } from '../HookNode';\r\n\r\nconst BUILTIN_PROPS = ['ref', 'key'];\r\n// TODO - We'll see if this is necessary - unmounted\r\n\r\nconst compStack: CompNode[] = [];\r\nexport function getCurrentCompNode() {\r\n  return compStack[compStack.length - 1];\r\n}\r\n\r\nexport function enterCompNode(compNode: CompNode) {\r\n  compStack.push(compNode);\r\n}\r\n\r\nexport function leaveCompNode() {\r\n  compStack.pop();\r\n}\r\n\r\ntype DerivedStateComputation = [() => Value, () => Value[], Bits, string];\r\ntype HookComputation = [(dirty: Bits) => void];\r\n\r\nexport abstract class ReactiveNode {\r\n  cachedDependenciesMap?: Record<string, Value[]>;\r\n\r\n  computations?: Array<DerivedStateComputation | HookComputation>;\r\n\r\n  derivedCount?: number;\r\n\r\n  owner?: CompNode;\r\n\r\n  abstract wave(_: Value, dirty: Bits): void;\r\n\r\n  constructor() {\r\n    this.owner = getCurrentCompNode();\r\n  }\r\n\r\n  deriveState(updateDerivedFunc: () => Value, dependenciesFunc: () => Value[], reactBits: Bits) {\r\n    if (!this.computations) this.computations = [];\r\n    // ---- Run the updateDerivedFunc to get the initial value\r\n    updateDerivedFunc();\r\n    // ---- Add to cachedDependenciesMap\r\n    if (!this.cachedDependenciesMap) this.cachedDependenciesMap = {};\r\n    if (this.derivedCount === undefined) this.derivedCount = 0;\r\n    const cacheKey = `derived$${this.derivedCount}`;\r\n    this.cachedDependenciesMap[cacheKey] = dependenciesFunc();\r\n    this.computations.push([updateDerivedFunc, dependenciesFunc, reactBits, cacheKey]);\r\n    this.derivedCount++;\r\n  }\r\n\r\n  watch(updateDerivedFunc: () => Value, dependenciesFunc: () => Value[], reactBits: Bits) {\r\n    this.deriveState(updateDerivedFunc, dependenciesFunc, reactBits);\r\n  }\r\n\r\n  updateState(dirty: Bits) {\r\n    if (!this.computations) return;\r\n    for (let i = 0; i < this.computations.length; i++) {\r\n      const computation = this.computations[i];\r\n      if (computation.length === 1) {\r\n        const [updateFn] = computation;\r\n        updateFn(dirty);\r\n        continue;\r\n      }\r\n\r\n      const [updateDerivedFunc, dependenciesFunc, reactBits, cacheKey] = computation;\r\n      // ---- Hooks\r\n      if (!reactBits) {\r\n        updateDerivedFunc();\r\n        continue;\r\n      }\r\n      // ---- If the state is not dirty, skip the update\r\n      if (!(dirty & reactBits)) continue;\r\n      const dependencies = dependenciesFunc();\r\n      const cachedDeps = this.cachedDependenciesMap?.[cacheKey];\r\n      // ---- If the dependencies are the same, skip the update\r\n      if (cached(dependencies, cachedDeps)) continue;\r\n      updateDerivedFunc();\r\n      this.cachedDependenciesMap![cacheKey] = dependencies;\r\n    }\r\n  }\r\n\r\n  // ---- Out of component update START ----\r\n  // ---- PROPS START ----\r\n  updatePropMap?: Record<string, [(value: Value) => void, Bits]>;\r\n  addProp(propName: string, updatePropFunc: (value: Value) => void, waveBits: Bits) {\r\n    if (!this.updatePropMap) this.updatePropMap = {};\r\n    this.updatePropMap[propName] = [updatePropFunc, waveBits];\r\n  }\r\n\r\n  executePropUpdate(\r\n    updatePropMap: Record<string, [(value: Value) => void, Bits]>,\r\n    propName: string,\r\n    valueFunc: () => Value\r\n  ) {\r\n    if (updatePropMap['$whole$']) {\r\n      const [updatePropFunc, waveBits] = updatePropMap['$whole$'];\r\n      if (propName === '*spread*') {\r\n        this.wave(updatePropFunc(valueFunc()), waveBits);\r\n      } else {\r\n        this.wave(updatePropFunc({ [propName]: valueFunc() }), waveBits);\r\n      }\r\n    } else if (updatePropMap[propName]) {\r\n      const [updatePropFunc, waveBits] = updatePropMap[propName];\r\n      this.wave(updatePropFunc(valueFunc()), waveBits);\r\n    } else {\r\n      // ---- Rest props\r\n      const [updatePropFunc, waveBits] = updatePropMap['$rest$'];\r\n      this.wave(updatePropFunc({ [propName]: valueFunc() }), waveBits);\r\n    }\r\n  }\r\n  // ---- PROP END ----\r\n\r\n  // ---- CONTEXT START ----\r\n  updateContextMap?: Record<string, [ContextID, (value: Value) => void, Bits]>;\r\n\r\n  addContext(context: Context, contextName: string, updateContextFunc: (value: Value) => void, waveBits: Bits) {\r\n    if (!this.updateContextMap) this.updateContextMap = {};\r\n    this.updateContextMap[contextName] = [context.id, updateContextFunc, waveBits];\r\n  }\r\n\r\n  updateContext(contextId: ContextID, contextName: string, value: Value) {\r\n    if (!this.updateContextMap || !(contextName in this.updateContextMap)) return;\r\n    const [expectedContextId, updateContextFunc, waveBits] = this.updateContextMap[contextName];\r\n    if (contextId !== expectedContextId) return;\r\n    this.wave(updateContextFunc(value), waveBits);\r\n  }\r\n  // ---- CONTEXT END ----\r\n\r\n  // ---- HOOKS START ----\r\n  useHook(hookNode: HookNode, emit: (value: Value) => void, hookUpdater: (hookNode: HookNode) => void) {\r\n    emit(hookNode.value!());\r\n    hookNode.triggerUpdate = () => {\r\n      emit(hookNode.value!());\r\n    };\r\n\r\n    if (!this.computations) this.computations = [];\r\n    if (this.derivedCount === undefined) this.derivedCount = 0;\r\n    this.computations.push([\r\n      dirty => {\r\n        hookNode.propDirtyBits = dirty;\r\n        hookUpdater(hookNode);\r\n      },\r\n    ]);\r\n  }\r\n  // ---- HOOKS END ----\r\n\r\n  // ---- Lifecycles\r\n  didMount(fn: Lifecycle) {\r\n    addDidMount(fn);\r\n  }\r\n\r\n  willUnmount(fn: Lifecycle) {\r\n    addWillUnmount(fn);\r\n  }\r\n\r\n  didUnmount(fn: Lifecycle) {\r\n    addDidUnmount(fn);\r\n  }\r\n}\r\n\r\n/**\r\n * @brief Component Node\r\n * @description\r\n * ---- Extract CompNode as a class especially for function 'updateDerived',\r\n *      because if we assign a default function to an object,\r\n *      it'll be counted in memory usage for each object.\r\n *      But if we assign a function to a class, it'll be counted only once.\r\n * ---- Also, for some must-use functions, we can assign them to the class prototype.\r\n *      Other helper functions will be coded as separate functions with\r\n *      a CompNode instance as the first parameter.\r\n * ---- Updating:\r\n *     - updateState: parameter is an dirty\r\n *        because we need to maintain the order of the state updates\r\n *     - updateView: parameter is a merged dirty\r\n *        because we need to update the view only once in the next microtask\r\n */\r\nexport class CompNode extends ReactiveNode implements InulaBaseNode {\r\n  inulaType = InulaNodeType.Comp;\r\n\r\n  // ---- All children nodes\r\n  nodes?: InulaBaseNode[];\r\n\r\n  // ---- Update functions\r\n  updater?: Updater<CompNode>;\r\n\r\n  subComponents?: CompNode[];\r\n\r\n  slices?: InulaBaseNode[];\r\n\r\n  unmounted = false;\r\n  setUnmounted = () => {\r\n    this.unmounted = true;\r\n  };\r\n\r\n  constructor(parentComponents: CompNode[]) {\r\n    super();\r\n    for (let i = 0; i < parentComponents.length; i++) {\r\n      if (parentComponents[i].subComponents) {\r\n        parentComponents[i].subComponents!.push(this);\r\n      } else {\r\n        parentComponents[i].subComponents = [this];\r\n      }\r\n    }\r\n\r\n    this.didMount(() => {\r\n      this.unmounted = false;\r\n    });\r\n    this.dirtyBits = InitDirtyBitsMask;\r\n  }\r\n\r\n  updateProp(propName: string, valueFunc: () => Value, dependencies: Value[], reactBits: Bits) {\r\n    if (BUILTIN_PROPS.includes(propName)) {\r\n      return;\r\n    }\r\n    // ---- Not event rest props is defined\r\n    if (!this.updatePropMap) return;\r\n    // ---- If not reacting to the change\r\n    if (!(reactBits & this.owner!.dirtyBits!)) return;\r\n    const cacheKey = `prop$${propName}`;\r\n    const cachedDeps = this.cachedDependenciesMap?.[cacheKey];\r\n    // ---- If the dependencies are the same, skip the update\r\n    if (cached(dependencies, cachedDeps)) return;\r\n\r\n    this.executePropUpdate(this.updatePropMap, propName, valueFunc);\r\n\r\n    if (!this.cachedDependenciesMap) this.cachedDependenciesMap = {};\r\n    this.cachedDependenciesMap[cacheKey] = dependencies;\r\n  }\r\n\r\n  // ---- In component update START----\r\n  wave(_: Value, dirty: Bits) {\r\n    this.updateState(dirty);\r\n    this.updateViewAsync(dirty);\r\n  }\r\n\r\n  dirtyBits?: Bits;\r\n  /**\r\n   * @brief Update view asynchronously\r\n   * @param dirty\r\n   * @returns\r\n   */\r\n  updateViewAsync(dirty: Bits) {\r\n    if (this.dirtyBits && this.dirtyBits !== InitDirtyBitsMask) {\r\n      this.dirtyBits |= dirty;\r\n      return;\r\n    }\r\n    this.dirtyBits = dirty;\r\n    // ---- Schedule the updateView in the next microtask\r\n    schedule(() => {\r\n      if (this.unmounted) {\r\n        return;\r\n      }\r\n      // ---- Merge all the dirtyBitsArrToUpdate to one single dirty\r\n      // ---- e.g. [0b0101, 0b0010] -> 0b0111\r\n      // ---- Call the updateView with the merged dirty bits to update\r\n      //       1. All the returning nodes\r\n      for (let i = 0; i < (this.nodes?.length ?? 0); i++) {\r\n        update(this.nodes![i]);\r\n      }\r\n      //       2. All the sub components\r\n      for (let i = 0; i < (this.subComponents?.length ?? 0); i++) {\r\n        this.subComponents![i].wave(null, dirty);\r\n      }\r\n      for (let i = 0; i < (this.slices?.length ?? 0); i++) {\r\n        update(this.slices![i]);\r\n      }\r\n      // ---- Clear the dirtyBits after the updateView is called\r\n      delete this.dirtyBits;\r\n    });\r\n  }\r\n\r\n  prepare() {\r\n    return this;\r\n  }\r\n\r\n  init(node: InulaBaseNode) {\r\n    this.nodes = [node];\r\n    compStack.pop();\r\n    delete this.dirtyBits;\r\n\r\n    return this;\r\n  }\r\n\r\n  update() {\r\n    this.updater?.(this);\r\n  }\r\n}\r\n\r\n/**\r\n * @brief Create a component node\r\n * @returns\r\n */\r\nexport const compBuilder = (...parentComponents: CompNode[]) => {\r\n  const comp = new CompNode(parentComponents);\r\n  enterCompNode(comp);\r\n  return comp;\r\n};\r\n\r\nexport const createCompNode = (\r\n  compFn: (props: Record<string, Value>) => CompNode,\r\n  props: Record<string, Value>,\r\n  updater: Updater<CompNode> | null\r\n) => {\r\n  if (props && props['*spread*']) {\r\n    const spreadProps = props['*spread*'];\r\n    delete props['*spread*'];\r\n    Object.assign(props, spreadProps);\r\n  }\r\n  const compNode = compFn(props);\r\n  if (updater) compNode.updater = updater;\r\n  return compNode;\r\n};\r\n\r\n/**\r\n * Handle children nodes, like:\r\n * <Button><Child /></Button>\r\n * will be transformed to\r\n * <Button>{createChildren(() => <Child />)}</Button>\r\n *\r\n * We need bind the children nodes to the current compNode,\r\n * so that the children nodes can be updated when the compNode is updated.\r\n * @param nodesFn\r\n * @param compNode\r\n * @returns\r\n */\r\nexport function createChildren(nodesFn: () => InulaBaseNode[], compNode: CompNode) {\r\n  const getter = () => {\r\n    enterCompNode(compNode);\r\n    let children = nodesFn();\r\n    leaveCompNode();\r\n\r\n    if (!Array.isArray(children)) {\r\n      children = [children];\r\n    }\r\n    if (compNode.slices) {\r\n      compNode.slices.push(...children);\r\n    } else {\r\n      compNode.slices = [...children];\r\n    }\r\n    return children;\r\n  };\r\n  getter.$$isChildren = true;\r\n\r\n  return getter;\r\n}\r\n","import { Bits, InulaBaseNode, Value } from '../../types';\nimport {\n  getFlowIndexFromNodes,\n  appendNodesWithIndex,\n  addParentElement,\n  appendNodes,\n  cached,\n  willReact,\n} from '../utils';\nimport { InulaHTMLNode, InulaTextNode } from './types';\n\n/**\n * @brief Insert any DLNode into an element, set the nodes and append the element to the element's children\n * @param el\n * @param node\n * @param position\n */\nexport const insertNode = (el: InulaHTMLNode, node: InulaBaseNode, position: number) => {\n  if (node == null) return;\n  // ---- Set nodes\n  if (!el.nodes) el.nodes = Array.from(el.childNodes) as InulaHTMLNode[];\n  el.nodes.splice(position, 0, node);\n\n  // ---- Insert nodes' elements\n  const flowIdx = getFlowIndexFromNodes(el.nodes, node);\n  appendNodesWithIndex([node], el, flowIdx);\n  // ---- Set parentEl\n  addParentElement([node], el);\n};\n\n/**\n * @brief Check if the node should update\n * @param node\n * @param key\n * @param dependencies\n * @param reactBits\n * @returns\n */\nexport const shouldUpdate = (\n  node: InulaHTMLNode | InulaTextNode,\n  key: string,\n  dependencies: Value[],\n  reactBits: Bits\n) => {\n  // ---- If not reacting to the change\n  if (!willReact(node.__$owner!.dirtyBits!, reactBits)) return false;\n  // ---- If not cached\n  if (cached(dependencies, node[`c$${key}`])) return false;\n  node[`c$${key}`] = dependencies;\n\n  return true;\n};\n\nexport const getElementByPosition = (element: HTMLElement, ...positions: number[]) => {\n  let current = element;\n\n  for (let i = 0; i < positions.length; i++) {\n    const pos = positions[i];\n    if (i < 2) {\n      // Use firstChild/nextSibling for first two levels\n      if (pos === 0) {\n        current = current.firstChild as HTMLElement;\n      } else {\n        let temp = current.firstChild as HTMLElement;\n        for (let j = 0; j < pos; j++) {\n          temp = temp.nextSibling as HTMLElement;\n        }\n        current = temp;\n      }\n    } else {\n      // Use childNodes[index] for deeper levels\n      current = current.childNodes[pos] as HTMLElement;\n    }\n  }\n\n  return current;\n};\n","import { InulaStore } from '../../store';\r\nimport { Bits, InulaBaseNode, Updater, Value } from '../../types';\r\nimport { getCurrentCompNode } from '../CompNode/node';\r\nimport { addParentElement, appendNodes, cached, InitDirtyBitsMask, update } from '../utils';\r\nimport { HTMLAttrsObject, InulaHTMLNode } from './types';\r\nimport { shouldUpdate } from './utils';\r\n\r\n/**\r\n * @brief Shortcut for document.createHTMLNode\r\n * @param tag\r\n * @returns InulaHTMLNode\r\n */\r\nexport const createHTMLNode = (tag: string, update: Updater<InulaHTMLNode>, ...childrenNodes: InulaBaseNode[]) => {\r\n  const node = InulaStore.document.createElement(tag) as InulaHTMLNode;\r\n  node.update = _update.bind(null, node, update);\r\n  node.__$owner = getCurrentCompNode();\r\n\r\n  update?.(node);\r\n\r\n  node.nodes = childrenNodes;\r\n\r\n  // ---- Append nodes' elements\r\n  appendNodes(childrenNodes, node);\r\n\r\n  // ---- Set parentEl\r\n  addParentElement(childrenNodes, node);\r\n\r\n  return node;\r\n};\r\n\r\n/**\r\n * @brief Update the HTML node and its children\r\n * @param node\r\n * @param htmlUpdate\r\n */\r\nconst _update = (node: InulaHTMLNode, htmlUpdate: Updater<InulaHTMLNode> | null) => {\r\n  htmlUpdate?.(node);\r\n  for (let i = 0; i < (node.nodes?.length ?? 0); i++) {\r\n    update(node.nodes![i]);\r\n  }\r\n};\r\n\r\n// ---- Without dependencies ----\r\n/**\r\n * @brief Set HTML property directly\r\n * @param node\r\n * @param key\r\n * @param value\r\n */\r\nconst _setHTMLProp = (node: InulaHTMLNode, key: string, value: Value) => {\r\n  (node as Record<string, Value>)[key] = value;\r\n};\r\n\r\n/**\r\n * @brief Check if it's a custom property, i.e. starts with '--'\r\n * @param name\r\n * @returns\r\n */\r\nconst isCustomProperty = (name: string): boolean => name.startsWith('--');\r\n\r\n/**\r\n * @brief Set style\r\n * @param node\r\n * @param newStyle\r\n * @returns\r\n */\r\nconst _setStyle = (node: InulaHTMLNode, newStyle: CSSStyleDeclaration) => {\r\n  const style = node.style;\r\n  const prevStyle = node.prevStyle ?? ({} as CSSStyleDeclaration);\r\n\r\n  // ---- Instead of resigning the whole style object,\r\n  //      we will compare the previous style with the new style\r\n  //      to reduce the number of operations\r\n\r\n  // ---- Remove styles that are no longer present\r\n  for (const key in prevStyle) {\r\n    if (prevStyle.hasOwnProperty(key) && (!newStyle || !newStyle.hasOwnProperty(key))) {\r\n      if (isCustomProperty(key)) {\r\n        style.removeProperty(key);\r\n      } else if (key === 'float') {\r\n        style.cssFloat = '';\r\n      } else {\r\n        style[key] = '';\r\n      }\r\n    }\r\n  }\r\n\r\n  // ---- Set new or dirty styles\r\n  for (const key in newStyle) {\r\n    const prevValue = prevStyle[key];\r\n    const newValue = newStyle[key];\r\n    if (newStyle.hasOwnProperty(key) && newValue !== prevValue) {\r\n      if (newValue == null || newValue === '' || typeof newValue === 'boolean') {\r\n        if (isCustomProperty(key)) {\r\n          style.removeProperty(key);\r\n        } else if (key === 'float') {\r\n          style.cssFloat = '';\r\n        } else {\r\n          style[key] = '';\r\n        }\r\n      } else if (isCustomProperty(key)) {\r\n        style.setProperty(key, newValue);\r\n      } else if (key === 'float') {\r\n        style.cssFloat = newValue;\r\n      } else if (typeof newValue === 'number') {\r\n        node.style[key] = newValue + 'px';\r\n      } else {\r\n        node.style[key] = newValue;\r\n      }\r\n    }\r\n  }\r\n\r\n  // ---- Store the new style for future comparisons\r\n  node.prevStyle = { ...newStyle };\r\n};\r\n\r\n/**\r\n * @brief Set dataset\r\n * @param node\r\n * @param value\r\n */\r\nconst _setDataset = (node: InulaHTMLNode, value: Record<string, string>) => {\r\n  Object.assign(node.dataset, value);\r\n};\r\n\r\n/**\r\n * @brief Set HTML properties\r\n * @param node\r\n * @param value\r\n */\r\nconst _setHTMLProps = (node: InulaHTMLNode, value: HTMLAttrsObject) => {\r\n  Object.entries(value).forEach(([key, v]) => {\r\n    if (key === 'style') return _setStyle(node, v);\r\n    if (key === 'dataset') return _setDataset(node, v);\r\n    _setHTMLProp(node, key, v);\r\n  });\r\n};\r\n\r\n/**\r\n * @brief Set HTML attribute\r\n * @param node\r\n * @param key\r\n * @param value\r\n */\r\nconst _setHTMLAttr = (node: InulaHTMLNode, key: string, value: string) => {\r\n  if (key === 'className') {\r\n    node.setAttribute('class', value);\r\n  } else {\r\n    node.setAttribute(key, value);\r\n  }\r\n};\r\n\r\n/**\r\n * @brief Set HTML attributes\r\n * @param node\r\n * @param value\r\n */\r\nconst _setHTMLAttrs = (node: InulaHTMLNode, value: HTMLAttrsObject) => {\r\n  Object.entries(value).forEach(([key, v]) => {\r\n    if (key === 'style') return _setStyle(node, v);\r\n    if (key === 'ref') return setRef(node, v);\r\n    _setHTMLAttr(node, key, v);\r\n  });\r\n};\r\n\r\n/**\r\n * @brief Set memorized event, store the previous event in node[`$on${key}`], if it exists, remove it first\r\n * @param node\r\n * @param key\r\n * @param value\r\n */\r\nconst _setEvent = (node: InulaHTMLNode, key: string, value: EventListener) => {\r\n  // ---- Not using elCached because it's not a value, but a function\r\n  const prevEvent = node[`me$${key}`];\r\n  if (prevEvent) node.removeEventListener(key, prevEvent);\r\n  node.addEventListener(key, value);\r\n  node[`me$${key}`] = value;\r\n};\r\n\r\n/**\r\n * @brief Event handler by checking if $$${key} exists in the path\r\n * @param e\r\n */\r\nconst eventHandler = (e: Event) => {\r\n  const key = `de$${e.type}`;\r\n  for (const node of e.composedPath()) {\r\n    if ((node as any)[key]) (node as any)[key](e);\r\n    // ---- Even though it's deprecated,\r\n    //      we still need it to manually stop the propagation in our event handler\r\n    if (e.cancelBubble) return;\r\n  }\r\n};\r\n\r\n/**\r\n * @brief Delegate event to the document instead of the element\r\n * @param node\r\n * @param key\r\n * @param value\r\n * @returns\r\n */\r\nconst _delegateEvent = (node: InulaHTMLNode, key: string, value: EventListener) => {\r\n  if (!node[`de$${key}`]) {\r\n    if (!InulaStore.delegatedEvents.has(key)) {\r\n      InulaStore.delegatedEvents.add(key);\r\n      InulaStore.document.addEventListener(key, eventHandler);\r\n    }\r\n  }\r\n  node[`de$${key}`] = value;\r\n};\r\n\r\n// ---- With dependencies ----\r\n\r\n/**\r\n * @brief Set HTML property\r\n * @param node\r\n * @param key\r\n * @param valueFunc\r\n * @param dependencies\r\n * @param reactBits\r\n */\r\nexport const setHTMLProp = (\r\n  node: InulaHTMLNode,\r\n  key: string,\r\n  valueFunc: () => Value,\r\n  dependencies: Value[],\r\n  reactBits: Bits\r\n) => {\r\n  if (!shouldUpdate(node, key, dependencies, reactBits)) return;\r\n  _setHTMLProp(node, key, valueFunc());\r\n};\r\n\r\n/**\r\n * @brief Set style\r\n * @param node\r\n * @param newStyleFunc\r\n * @param dependencies\r\n * @param reactBits\r\n */\r\nexport function setStyle(\r\n  node: InulaHTMLNode,\r\n  newStyleFunc: (() => CSSStyleDeclaration) | CSSStyleDeclaration,\r\n  dependencies?: Value[],\r\n  reactBits?: Bits\r\n): void {\r\n  if (reactBits) {\r\n    if (!shouldUpdate(node, 'style', dependencies!, reactBits)) return;\r\n    _setStyle(node, (newStyleFunc as () => CSSStyleDeclaration)());\r\n  } else {\r\n    _setStyle(node, newStyleFunc as CSSStyleDeclaration);\r\n  }\r\n}\r\n\r\n/**\r\n * @brief Set dataset properties\r\n * @param node The HTML node to update\r\n * @param valueFunc Function that returns dataset key-value pairs\r\n * @param dependencies Values this dataset depends on\r\n * @param reactBits Bits indicating which properties should react to changes\r\n */\r\nexport const setDataset = (\r\n  node: InulaHTMLNode,\r\n  valueFunc: () => Record<string, string>,\r\n  dependencies: Value[],\r\n  reactBits: Bits\r\n) => {\r\n  if (!shouldUpdate(node, 'dataset', dependencies, reactBits)) return;\r\n  _setDataset(node, valueFunc());\r\n};\r\n\r\n/**\r\n * @brief Set multiple HTML properties at once\r\n * @param node The HTML node to update\r\n * @param valueFunc Function that returns HTML properties object\r\n * @param dependencies Values these properties depend on\r\n * @param reactBits Bits indicating which properties should react to changes\r\n */\r\nexport const setHTMLProps = (\r\n  node: InulaHTMLNode,\r\n  valueFunc: () => HTMLAttrsObject,\r\n  dependencies: Value[],\r\n  reactBits: Bits\r\n) => {\r\n  // TODO Need to refactor\r\n  if (reactBits) {\r\n    if (!shouldUpdate(node, 'htmlProps', dependencies, reactBits)) return;\r\n    _setHTMLProps(node, valueFunc());\r\n  } else {\r\n    _setHTMLProps(node, valueFunc);\r\n  }\r\n};\r\n\r\n/**\r\n * @brief Set multiple HTML attributes at once\r\n * @param node The HTML node to update\r\n * @param valueFunc Function that returns HTML attributes object\r\n * @param dependencies Values these attributes depend on\r\n * @param reactBits Bits indicating which attributes should react to changes\r\n */\r\nexport const setHTMLAttrs = (\r\n  node: InulaHTMLNode,\r\n  valueFunc: () => HTMLAttrsObject,\r\n  dependencies: Value[],\r\n  reactBits: Bits\r\n) => {\r\n  if (!shouldUpdate(node, 'htmlAttrs', dependencies, reactBits)) return;\r\n  _setHTMLAttrs(node, valueFunc());\r\n};\r\n\r\n/**\r\n * @brief Set single HTML attribute\r\n * @param node The HTML node to update\r\n * @param key\r\n * @param valueFunc Function that returns HTML attribute\r\n * @param dependencies Values these attributes depend on\r\n * @param reactBits Bits indicating which attributes should react to changes\r\n */\r\nexport const setHTMLAttr = (\r\n  node: InulaHTMLNode,\r\n  key: string,\r\n  valueFunc: (() => Value) | Value,\r\n  dependencies: Value[],\r\n  reactBits: Bits\r\n) => {\r\n  // TODO Need to refactor\r\n  if (reactBits) {\r\n    if (!shouldUpdate(node, 'htmlAttrs', dependencies, reactBits)) return;\r\n    _setHTMLAttr(node, key, valueFunc());\r\n  } else {\r\n    _setHTMLAttr(node, key, valueFunc);\r\n  }\r\n};\r\n\r\n/**\r\n * @brief Set an event handler on a node\r\n */\r\nexport const setEvent = _setEvent;\r\n\r\n/**\r\n * @brief Delegate an event handler through event bubbling\r\n */\r\nexport const delegateEvent = (\r\n  node: InulaHTMLNode,\r\n  key: string,\r\n  valueFunc: () => EventListener,\r\n  dependencies: Value[],\r\n  reactBits: Bits\r\n) => {\r\n  if (reactBits) {\r\n    if (!shouldUpdate(node, key, dependencies, reactBits)) return;\r\n    _delegateEvent(node, key, valueFunc());\r\n  } else {\r\n    _delegateEvent(node, key, valueFunc);\r\n  }\r\n};\r\n\r\nexport function setRef(node: InulaHTMLNode, refFn: () => void) {\r\n  if (node.__$owner!.dirtyBits === InitDirtyBitsMask) {\r\n    refFn();\r\n  }\r\n}\r\n","import { InulaStore } from '../../store';\nimport { Bits, Updater, Value } from '../../types';\nimport { getCurrentCompNode } from '../CompNode/node';\nimport { InulaTextNode } from './types';\nimport { shouldUpdate } from './utils';\n\nexport const createTextNode = (text: string, update: Updater<InulaTextNode>) => {\n  const node = InulaStore.document.createTextNode(text) as InulaTextNode;\n  node.update = update;\n  node.__$owner = getCurrentCompNode();\n  return node;\n};\n\n/**\n * @brief Set the text content of the node\n * @param node\n * @param text\n */\nconst _setText = (node: Text, text: string) => {\n  node.textContent = text;\n};\n\nexport const setText = (node: InulaTextNode, text: string, dependencies: Value[], reactBits: Bits) => {\n  if (!shouldUpdate(node, 'text', dependencies, reactBits)) return;\n  _setText(node, text);\n};\n","import { InulaStore } from '../../store';\r\nimport { InulaBaseNode, Updater } from '../../types';\r\nimport { getCurrentCompNode } from '../CompNode/node';\r\nimport { addParentElement, InitDirtyBitsMask, update } from '../utils';\r\nimport { InulaHTMLNode, InulaHTMLTemplateNode, InulaTextNode } from './types';\r\nimport { getElementByPosition, insertNode } from './utils';\r\n\r\nexport const createTemplate = (template: string) => {\r\n  const templateElement = InulaStore.document.createElement('template');\r\n  templateElement.innerHTML = template;\r\n  return templateElement.content.children[0] as HTMLElement;\r\n};\r\n\r\nexport const createTemplateNode = (\r\n  template: HTMLElement,\r\n  getUpdater: ((node: InulaHTMLTemplateNode) => Updater<InulaHTMLTemplateNode>) | null,\r\n  ...nodesToInsert: [number, InulaBaseNode, ...number[]][]\r\n) => {\r\n  const node = template.cloneNode(true) as InulaHTMLTemplateNode;\r\n  node.__$owner = getCurrentCompNode();\r\n\r\n  const updater = getUpdater?.(node) ?? null;\r\n  node.update = _update.bind(null, node, updater);\r\n  // ---- Insert nodes\r\n  if (nodesToInsert.length > 0) {\r\n    // we need to find the parent element first, cause the position would be changed after insert\r\n    const insertOperations: Array<[InulaHTMLNode, InulaBaseNode, number]> = [];\r\n    for (let i = 0; i < nodesToInsert.length; i++) {\r\n      const [lastPos, nodeToInsert, ...position] = nodesToInsert[i];\r\n      const parentElement = getElementByPosition(node, ...position);\r\n      insertOperations.push([parentElement as InulaHTMLNode, nodeToInsert, lastPos]);\r\n    }\r\n\r\n    node.nodesInserted = [];\r\n    // insert nodes\r\n    for (let i = 0; i < insertOperations.length; i++) {\r\n      const [parentElement, nodeToInsert, lastPos] = insertOperations[i];\r\n      insertNode(parentElement as InulaHTMLNode, nodeToInsert, lastPos);\r\n      addParentElement([nodeToInsert], parentElement);\r\n      node.nodesInserted.push(nodeToInsert);\r\n    }\r\n  }\r\n\r\n  // --- append lately cause DOM should be stable to find the anchor element\r\n  if (updater) {\r\n    updater(node);\r\n  }\r\n\r\n  return node;\r\n};\r\n\r\nconst _update = (node: InulaHTMLTemplateNode, updater: Updater<InulaHTMLTemplateNode> | null) => {\r\n  if (updater) {\r\n    updater(node);\r\n  }\r\n\r\n  for (let i = 0; i < (node.nodesInserted?.length ?? 0); i++) {\r\n    update(node.nodesInserted![i]);\r\n  }\r\n};\r\n\r\nexport const templateAddNodeToUpdate = (node: InulaHTMLTemplateNode, nodeToAdd: InulaHTMLNode | InulaTextNode) => {\r\n  if (!node.elementsRetrieved) node.elementsRetrieved = [];\r\n  if (node.elementsRetrieved.includes(nodeToAdd)) return;\r\n  node.elementsRetrieved.push(nodeToAdd);\r\n  addParentElement([nodeToAdd], node);\r\n};\r\n\r\nexport const templateGetElement = (templateNode: InulaHTMLTemplateNode, ...positions: number[]) => {\r\n  const node = getElementByPosition(templateNode, ...positions) as InulaHTMLNode;\r\n  node.__$owner = getCurrentCompNode();\r\n  templateAddNodeToUpdate(templateNode, node);\r\n\r\n  return node;\r\n};\r\n","import { CompNode } from './Nodes/CompNode/node';\r\nimport { InulaHTMLNode } from './Nodes/HTMLNode/types';\r\nimport { insertNode } from './Nodes/HTMLNode';\r\nimport { runDidMount } from './lifecycle';\r\nimport { MutableContextNode } from './Nodes/MutableNodes/context';\r\n\r\n/**\r\n * @brief Render the component node to the container\r\n * @param compNode\r\n * @param container\r\n */\r\nexport const render = (compNode: CompNode, container: HTMLElement) => {\r\n  if (container == null) {\r\n    throw new Error('Render target is empty. Please provide a valid DOM element.');\r\n  }\r\n  container.innerHTML = '';\r\n  insertNode(container as InulaHTMLNode, compNode, 0);\r\n  runDidMount();\r\n};\r\n\r\n// export const unmount = (container: HTMLElement) => {\r\n//   if (!container?.nodes) return;\r\n//   const stack: Array<InulaBaseNode> = [...container.nodes].reverse();\r\n//   while (stack.length > 0) {\r\n//     const node = stack.pop()!;\r\n//     if (node == null) continue;\r\n//     if (node instanceof HTMLElement || node instanceof Text) {\r\n//       container.removeChild(node);\r\n//     } else if (node instanceof MutableContextNode) {\r\n//       if (node.willUnmountScopedStore?.length > 0) {\r\n//         node.runWillUnmount();\r\n//       }\r\n//       stack.push(...[...node.nodes].reverse());\r\n//     }\r\n//   }\r\n// };\r\n","import { InulaNodeType } from '../../consts';\nimport { Bits, InulaBaseNode } from '../../types';\nimport { update } from '../utils';\n\nclass FragmentNode implements InulaBaseNode {\n  inulaType = InulaNodeType.Fragment;\n\n  nodes;\n\n  constructor(nodes: InulaBaseNode[]) {\n    this.nodes = nodes;\n  }\n\n  update() {\n    for (let i = 0; i < this.nodes!.length; i++) {\n      update(this.nodes![i]);\n    }\n  }\n}\n\n/**\n * @brief Create a createFragmentNode node, will be unwrapped when rendered\n * @returns\n */\nexport const createFragmentNode = (...nodes: InulaBaseNode[]): InulaBaseNode => {\n  return new FragmentNode(nodes);\n};\n","import { Bits, Value, InulaBaseNode, Updater } from '../../types';\r\nimport { InulaNodeType } from '../../consts';\r\nimport { CompNode, getCurrentCompNode } from '../CompNode';\r\nimport { addWillUnmount } from '../../lifecycle';\r\nimport { InulaStore } from '../../store';\r\nimport { InitDirtyBitsMask, update, willReact } from '../utils';\r\nimport { cached } from '../utils';\r\n\r\nexport type ContextID = Symbol;\r\n\r\nexport type Context = {\r\n  id: ContextID;\r\n  defaultValue?: Record<string, Value>;\r\n};\r\n\r\nexport class ContextNode implements InulaBaseNode {\r\n  inulaType = InulaNodeType.Context;\r\n\r\n  owner: CompNode;\r\n\r\n  nodes?: InulaBaseNode[];\r\n\r\n  updater?: Updater<ContextNode>;\r\n\r\n  contextId: ContextID;\r\n\r\n  contexts: Record<string, Value> = {};\r\n\r\n  consumers: CompNode[] = [];\r\n\r\n  constructor(contextId: ContextID, updater?: Updater<ContextNode>) {\r\n    if (!InulaStore.global.CurrentContextStore) InulaStore.global.CurrentContextStore = [];\r\n    // TODO Check if same context is already in the store (can't allow nested same contexts)\r\n    this.contextId = contextId;\r\n    this.updater = updater;\r\n    this.owner = getCurrentCompNode();\r\n    this.init();\r\n    InulaStore.global.CurrentContextStore.push(this);\r\n  }\r\n\r\n  init() {\r\n    this.updater?.(this);\r\n  }\r\n\r\n  with(...children: InulaBaseNode[]) {\r\n    this.nodes = children;\r\n    InulaStore.global.CurrentContextStore.pop();\r\n    return this;\r\n  }\r\n\r\n  update() {\r\n    for (let i = 0; i < (this.nodes?.length ?? 0); i++) {\r\n      update(this.nodes![i]);\r\n    }\r\n    this.updater?.(this);\r\n  }\r\n\r\n  cachedDependenciesMap?: Record<string, Value[]>;\r\n  updateContext(contextName: string, valueFunc: () => Value, deps: Value[], reactBits: Bits) {\r\n    if (!willReact(this.owner.dirtyBits!, reactBits)) return;\r\n    if (!this.cachedDependenciesMap) this.cachedDependenciesMap = {};\r\n    const cachedDeps = this.cachedDependenciesMap![contextName];\r\n    if (cached(deps, cachedDeps)) return;\r\n    const value = valueFunc();\r\n    this.contexts[contextName] = value;\r\n    this.consumers.forEach(consumer => consumer.updateContext(this.contextId, contextName, value));\r\n    this.cachedDependenciesMap![contextName] = deps;\r\n  }\r\n}\r\n\r\nexport const createContextNode = (context: Context, updater?: (node: ContextNode) => void) => {\r\n  return new ContextNode(context.id, updater);\r\n};\r\n\r\nexport const createContext = (defaultValue?: Record<string, Value>) => {\r\n  return {\r\n    id: Symbol('inula-context'),\r\n    defaultValue,\r\n  };\r\n};\r\n\r\nconst removeConsumer = (contextNode: ContextNode, compNode: CompNode) => {\r\n  const index = contextNode.consumers.indexOf(compNode);\r\n  if (index > -1) contextNode.consumers.splice(index, 1);\r\n};\r\n\r\nexport const useContext = (context: Context, compNode?: CompNode) => {\r\n  if (!InulaStore.global.CurrentContextStore) {\r\n    return context.defaultValue ?? {};\r\n  }\r\n\r\n  for (let i = InulaStore.global.CurrentContextStore.length - 1; i >= 0; i--) {\r\n    const currentContext = InulaStore.global.CurrentContextStore[i];\r\n    if (currentContext.contextId === context.id) {\r\n      if (compNode) {\r\n        currentContext.consumers.push(compNode);\r\n        // ---- Remove the consumer from the context when the component unmounts\r\n        addWillUnmount(removeConsumer.bind(null, currentContext, compNode));\r\n      }\r\n      return currentContext.contexts;\r\n    }\r\n  }\r\n  return context.defaultValue ?? {};\r\n};\r\n","import { CompNode, getCurrentCompNode } from '../..';\nimport { InulaNodeType } from '../../consts';\nimport { InulaStore } from '../../store';\nimport { InulaBaseNode } from '../../types';\nimport { InulaHTMLNode } from '../HTMLNode/types';\nimport { ContextNode, PortalNode } from '../UtilNodes';\nimport { addParentElement, loopShallowElements } from '../utils';\n\nexport class MutableContextNode {\n  savedContextNodes: ContextNode[] = [];\n\n  parentEl?: InulaHTMLNode;\n  owner: CompNode;\n\n  /**\n   * @brief Mutable node is a node that this._$nodes can be changed, things need to pay attention:\n   *  1. The environment of the new nodes should be the same as the old nodes\n   *  2. The new nodes should be added to the parentEl\n   *  3. The old nodes should be removed from the parentEl\n   * @param type\n   */\n  constructor() {\n    this.owner = getCurrentCompNode();\n\n    // ---- Save the current environment nodes, must be a new reference\n    if (InulaStore.global.CurrentContextStore && InulaStore.global.CurrentContextStore.length > 0) {\n      this.savedContextNodes = [...InulaStore.global.CurrentContextStore];\n    }\n  }\n\n  /**\n   * @brief Initialize the new nodes, add parentEl to all nodes\n   * @param nodes\n   */\n  initNewNodes(nodes: InulaBaseNode[]) {\n    addParentElement(nodes, this.parentEl!);\n  }\n\n  /**\n   * @brief Generate new nodes in the saved environment\n   * @param newNodesFunc\n   * @returns\n   */\n  newNodesInContext(newNodesFunc: () => InulaBaseNode[]) {\n    if (!this.savedContextNodes) {\n      // ---- No saved environment, just generate new nodes\n      const newNodes = newNodesFunc();\n      // ---- Only for IfNode's same condition return\n      // ---- Initialize the new nodes\n      this.initNewNodes(newNodes);\n      return newNodes;\n    }\n    // ---- Save the current environment nodes\n    const currentEnvNodes = InulaStore.global.CurrentContextStore;\n    // ---- Replace the saved environment nodes\n    InulaStore.global.CurrentContextStore = [...this.savedContextNodes];\n    const newNodes = newNodesFunc();\n    // ---- Retrieve the current environment nodes\n    InulaStore.global.CurrentContextStore = currentEnvNodes;\n    // ---- Only for IfNode's same condition return\n    // ---- Initialize the new nodes\n    this.initNewNodes(newNodes);\n    return newNodes;\n  }\n\n  /**\n   * @brief Remove nodes from parentEl and run willUnmount and didUnmount\n   * @param nodes\n   * @param removeEl Only remove outermost element\n   */\n  removeNodes(nodes: InulaBaseNode[], parentEl?: InulaHTMLNode) {\n    if (!parentEl) parentEl = this.parentEl!;\n    removeNodes(nodes, parentEl);\n  }\n\n  initUnmountStore() {\n    if (!InulaStore.global.WillUnmountScopedStore) InulaStore.global.WillUnmountScopedStore = [];\n    if (!InulaStore.global.DidUnmountScopedStore) InulaStore.global.DidUnmountScopedStore = [];\n    InulaStore.global.WillUnmountScopedStore.push([]);\n    InulaStore.global.DidUnmountScopedStore.push([]);\n  }\n}\n\nfunction removeNodes(nodes: InulaBaseNode[], parentEl: InulaHTMLNode) {\n  const stack: Array<InulaBaseNode> = [...nodes].reverse();\n  while (stack.length > 0) {\n    const node = stack.pop()!;\n    if (node == null) continue;\n    if (node instanceof HTMLElement || node instanceof Text) {\n      parentEl.removeChild(node);\n    } else if (node.inulaType === InulaNodeType.Portal) {\n      const portalNode = node as PortalNode;\n      removeNodes(portalNode.nodes, portalNode.target);\n    } else if (node.nodes) {\n      // @ts-expect-error to be removed\n      if (node.willUnmountScopedStore?.length > 0) {\n        // @ts-expect-error to be removed\n        node.runWillUnmount();\n      }\n      stack.push(...[...node.nodes].reverse());\n    }\n  }\n}\n","import { InulaBaseNode } from '../../types';\nimport { InulaStore } from '../../store';\nimport { MutableContextNode } from './context';\nimport { enterCompNode } from '../CompNode/node';\nimport { leaveCompNode } from '../CompNode/node';\nimport { addDidUnmount, addWillUnmount } from '../../lifecycle';\n\nexport class MutableLifecycleNode extends MutableContextNode {\n  willUnmountScopedStore?: (() => void)[];\n  didUnmountScopedStore?: (() => void)[];\n\n  constructor() {\n    super();\n  }\n\n  setUnmountFuncs() {\n    this.willUnmountScopedStore = InulaStore.global.WillUnmountScopedStore.pop();\n    this.didUnmountScopedStore = InulaStore.global.WillUnmountScopedStore.pop();\n  }\n\n  runWillUnmount = () => {\n    if (!this.willUnmountScopedStore) return;\n    for (let i = 0; i < this.willUnmountScopedStore.length; i++) this.willUnmountScopedStore[i]();\n  };\n\n  runDidUnmount = () => {\n    if (!this.didUnmountScopedStore) return;\n    for (let i = this.didUnmountScopedStore.length - 1; i >= 0; i--) this.didUnmountScopedStore[i]();\n  };\n\n  removeNodes(nodes: InulaBaseNode[]) {\n    this.runWillUnmount();\n    super.removeNodes(nodes);\n    this.runDidUnmount();\n  }\n\n  newNodesInContext(newNodesFunc: () => InulaBaseNode[]) {\n    enterCompNode(this.owner);\n    this.initUnmountStore();\n    const newNodes = super.newNodesInContext(newNodesFunc);\n    this.setUnmountFuncs();\n    leaveCompNode();\n    return newNodes;\n  }\n}\n","import { Component, InulaBaseNode } from '../../types';\r\nimport { createExpNode } from './expression';\r\nimport { createConditionalNode } from './conditional';\r\nimport { Context, ContextNode, createContext, createContextNode, useContext } from '../UtilNodes/context';\r\nimport { compBuilder, getCurrentCompNode } from '../CompNode/node';\r\nimport { MutableLifecycleNode } from './lifecycle';\r\nimport { appendNodesWithSibling, getFlowIndexFromNodes, init, InitDirtyBitsMask, update } from '../utils';\r\nimport { runDidMount } from '../../lifecycle';\r\nimport { InulaNodeType } from '../../consts';\r\n\r\nlet suspenseContext: Context | null = null;\r\nfunction getSuspenseContext() {\r\n  if (!suspenseContext) {\r\n    suspenseContext = createContext();\r\n  }\r\n  return suspenseContext;\r\n}\r\n\r\nclass SuspenseNode extends MutableLifecycleNode implements InulaBaseNode{\r\n  inulaType = InulaNodeType.Suspense;\r\n  didSuspend = false;\r\n  promiseSet = new Set<PromiseType<{ default: Component }>>();\r\n  fallbackNode!: InulaBaseNode;\r\n  children!: InulaBaseNode[];\r\n  contextNode: ContextNode;\r\n  nodes: InulaBaseNode[] = [];\r\n  constructor() {\r\n    super();\r\n    this.contextNode = createContextNode(getSuspenseContext(), $$node => {\r\n      $$node.updateContext('handlePromise', () => this.handlePromise.bind(this), [], 0);\r\n    });\r\n    this.nodes = [this.contextNode];\r\n  }\r\n\r\n  with(children: InulaBaseNode[]) {\r\n    this.children = children;\r\n    if (!this.didSuspend) {\r\n      this.contextNode.with(...this.children);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  fallback(fallback: () => InulaBaseNode) {\r\n    this.fallbackNode = fallback();\r\n    return this;\r\n  }\r\n\r\n  clearPromise(promise: PromiseType<{ default: Component }>) {\r\n    this.promiseSet.delete(promise);\r\n    if (this.promiseSet.size === 0) {\r\n      this.didSuspend = false;\r\n      this.toggle();\r\n    }\r\n  }\r\n\r\n  handlePromise(promise: PromiseType<{ default: Component }>) {\r\n    if (this.promiseSet.has(promise)) return;\r\n    if (this.didSuspend === false) {\r\n      this.didSuspend = true;\r\n      this.toggle();\r\n    }\r\n    this.promiseSet.add(promise);\r\n    const clear = this.clearPromise.bind(this, promise);\r\n    promise.then(clear, clear);\r\n  }\r\n\r\n  toggle() {\r\n    const compNode = getCurrentCompNode();\r\n    if (compNode && compNode.dirtyBits === InitDirtyBitsMask) {\r\n      this.contextNode.nodes = this.getCurrentContent();\r\n    } else {\r\n      this.render();\r\n    }\r\n  }\r\n  getCurrentContent() {\r\n    if (this.didSuspend) {\r\n      return [this.fallbackNode];\r\n    } else {\r\n      return this.children;\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const prevFuncs = [this.willUnmountScopedStore, this.didUnmountScopedStore];\r\n    const newNodes = this.newNodesInContext(() => {\r\n      return this.getCurrentContent();\r\n    });\r\n\r\n    const newFuncs = [this.willUnmountScopedStore, this.didUnmountScopedStore];\r\n    [this.willUnmountScopedStore, this.didUnmountScopedStore] = prevFuncs;\r\n    if (this.contextNode.nodes && this.contextNode.nodes.length > 0) {\r\n      this.removeNodes(this.contextNode.nodes);\r\n    }\r\n    [this.willUnmountScopedStore, this.didUnmountScopedStore] = newFuncs;\r\n\r\n    this.contextNode.nodes = newNodes;\r\n    if (this.contextNode.nodes.length === 0) return;\r\n\r\n    // ---- Faster append with nextSibling rather than flowIndex\r\n    const flowIndex = getFlowIndexFromNodes(this.parentEl!.nodes!, this);\r\n    const nextSibling = this.parentEl!.childNodes[flowIndex];\r\n\r\n    appendNodesWithSibling(this.nodes, this.parentEl!, nextSibling);\r\n    init(this.nodes!);\r\n\r\n    runDidMount();\r\n  }\r\n\r\n  update() {\r\n    for (let i = 0; i < (this.nodes?.length ?? 0); i++) {\r\n      update(this.nodes![i]);\r\n    }\r\n  }\r\n}\r\n\r\nexport function createSuspenseNode() {\r\n  return new SuspenseNode();\r\n}\r\n\r\nexport interface PromiseType<R> {\r\n  then<U>(\r\n    onFulfill: (value: R) => void | PromiseType<U> | U,\r\n    onReject: (error: any) => void | PromiseType<U> | U\r\n  ): void | PromiseType<U>;\r\n}\r\n\r\nexport function lazy<T extends Component>(promiseConstructor: () => PromiseType<{ default: T }>) {\r\n  let value: T | null = null;\r\n  let promise: PromiseType<{ default: T }> | null = null;\r\n  let status = 'init';\r\n  const instance: InulaBaseNode = {\r\n    nodes: [],\r\n  };\r\n  return function (props: Record<string, any>) {\r\n    const { handlePromise } = useContext(getSuspenseContext());\r\n    if (status === 'init') {\r\n      status = 'pending';\r\n      promise = promiseConstructor();\r\n      promise.then(\r\n        function (module) {\r\n          value = module.default;\r\n          status = 'fullfilled';\r\n          instance.nodes = [value(props)];\r\n        },\r\n        function (error) {\r\n          status = 'rejected';\r\n          value = error;\r\n        }\r\n      );\r\n    }\r\n    if (status !== 'fullfilled') {\r\n      handlePromise(promise);\r\n    }\r\n    return instance;\r\n  };\r\n}\r\n","import { compBuilder } from '../CompNode/node';\r\nimport { createContextNode, createConditionalNode, createExpNode, InulaBaseNode, createContext, Context } from '../..';\r\n\r\nlet errorBoundaryContext: Context | null = null;\r\nfunction getSuspenseContext() {\r\n  if (!errorBoundaryContext) {\r\n    errorBoundaryContext = createContext();\r\n  }\r\n  return errorBoundaryContext;\r\n}\r\n\r\nfunction catchError<T>(fn: () => T, handler: (error: Error) => void) {\r\n  try {\r\n    return fn();\r\n  } catch (error) {\r\n    handler(error as Error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function ErrorBoundary({\r\n  fallback,\r\n  children,\r\n}: {\r\n  fallback: (error: Error) => InulaBaseNode[];\r\n  children: () => InulaBaseNode[];\r\n}) {\r\n  const $$self = compBuilder();\r\n\r\n  let error: Error | null = null;\r\n  function handler(err: Error) {\r\n    $$self.wave((error = err), 4 /*0b100*/);\r\n  }\r\n  return $$self.prepare().init(\r\n    createConditionalNode($$node => {\r\n      if ($$node.cachedCondition(0, () => error, [error])) {\r\n        if ($$node.branch(0)) return [];\r\n        return [\r\n          createExpNode(\r\n            () => fallback(error!),\r\n            () => [fallback],\r\n            1\r\n          ),\r\n        ];\r\n      } else {\r\n        if ($$node.branch(1)) return [];\r\n        return [\r\n          createExpNode(\r\n            () => catchError(children, handler),\r\n            () => [children],\r\n            2\r\n          ),\r\n        ];\r\n      }\r\n    }, 4)\r\n  );\r\n}\r\n","import { InulaNodeType } from '../../consts';\r\nimport { InulaStore } from '../../store';\r\nimport { InulaBaseNode } from '../../types';\r\nimport { InulaHTMLNode } from '../HTMLNode';\r\nimport { appendNodes, addParentElement, update } from '../utils';\r\n\r\nexport interface PortalNode extends InulaBaseNode {\r\n  inulaType: InulaNodeType.Portal;\r\n  nodes: InulaBaseNode[];\r\n  target: InulaHTMLNode;\r\n}\r\n\r\nfunction updatePortal(node: PortalNode) {\r\n  for (let i = 0; i < node.nodes.length; i++) {\r\n    update(node.nodes[i]);\r\n  }\r\n}\r\n\r\nexport function createPortal(props: { target?: HTMLElement }, ...children: InulaBaseNode[]): PortalNode {\r\n  const target = props.target ?? InulaStore.document.body;\r\n  appendNodes(children, target);\r\n  addParentElement(children, target);\r\n\r\n  return { inulaType: InulaNodeType.Portal, target: target as InulaHTMLNode, nodes: children, update: updatePortal };\r\n}\r\n\r\nexport function Portal(props: { target?: HTMLElement; children: InulaBaseNode[] }) {\r\n  throw new Error('Portal should be compiled to a createPortal');\r\n}\r\n","import { Bits, InulaBaseNode, Value } from '../../types';\r\nimport { ReactiveNode } from '../CompNode';\r\nimport { cached } from '../utils';\r\n\r\nexport class HookNode extends ReactiveNode {\r\n  value?: () => Value;\r\n  triggerUpdate?: () => void;\r\n  propDirtyBits = 0;\r\n  updateProp: (propName: string, valueFunc: () => Value, dependencies: Value[], reactBits: Bits) => void = (\r\n    propName,\r\n    valueFunc,\r\n    dependencies,\r\n    reactBits\r\n  ) => {\r\n    // ---- Not event rest props is defined\r\n    if (!this.updatePropMap) return;\r\n    // ---- If not reacting to the change\r\n    if (!(reactBits & this.propDirtyBits)) return;\r\n    const cacheKey = `prop$${propName}`;\r\n    const cachedDeps = this.cachedDependenciesMap?.[cacheKey];\r\n    // ---- If the dependencies are the same, skip the update\r\n    if (cached(dependencies, cachedDeps)) return;\r\n\r\n    this.executePropUpdate(this.updatePropMap, propName, valueFunc);\r\n\r\n    if (!this.cachedDependenciesMap) this.cachedDependenciesMap = {};\r\n    this.cachedDependenciesMap[cacheKey] = dependencies;\r\n  };\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  wave(_: Value, dirty: Bits): void {\r\n    this.updateState(dirty);\r\n    this.triggerUpdate?.();\r\n  }\r\n\r\n  init(value: () => Value, dependencies: () => Value[], reactBits: Bits): this {\r\n    this.value = value;\r\n    return this;\r\n  }\r\n}\r\n\r\nexport const hookBuilder = (): HookNode => {\r\n  return new HookNode();\r\n};\r\n","import { InulaNodeType } from '../../consts';\r\nimport { runDidMount } from '../../lifecycle';\r\nimport { Bits, InulaBaseNode, Value } from '../../types';\r\nimport { getCurrentCompNode } from '../CompNode/node';\r\nimport { appendNodesWithSibling, cached, getFlowIndexFromNodes, init, update } from '../utils';\r\nimport { MutableLifecycleNode } from './lifecycle';\r\n\r\nclass ConditionalNode extends MutableLifecycleNode implements InulaBaseNode {\r\n  inulaType = InulaNodeType.Cond;\r\n\r\n  nodes?: InulaBaseNode[];\r\n\r\n  currentBranch = -1;\r\n\r\n  updater;\r\n\r\n  reactBits: Bits;\r\n\r\n  constructor(updater: (node: ConditionalNode) => InulaBaseNode[], reactBits: Bits) {\r\n    super();\r\n    this.updater = updater;\r\n    this.reactBits = reactBits;\r\n    this.initUnmountStore();\r\n    this.nodes = updater(this);\r\n    this.setUnmountFuncs();\r\n  }\r\n\r\n  conditionCacheMap?: Record<string, [boolean, Value[]]>;\r\n\r\n  branch(branchNum: number) {\r\n    if (this.currentBranch === branchNum) return true;\r\n    this.currentBranch = branchNum;\r\n    return false;\r\n  }\r\n\r\n  cachedCondition(branchNum: number, valueFunc: () => Value, dependencies: Value[]) {\r\n    if (!this.conditionCacheMap) this.conditionCacheMap = {};\r\n    const [cachedValue, cachedDeps] = this.conditionCacheMap[branchNum] ?? [null, null];\r\n    if (cached(dependencies, cachedDeps)) return cachedValue;\r\n    const value = valueFunc();\r\n    this.conditionCacheMap[branchNum] = [value, dependencies];\r\n    return value;\r\n  }\r\n\r\n  update() {\r\n    const prevBranch = this.currentBranch;\r\n    const prevFuncs = [this.willUnmountScopedStore, this.didUnmountScopedStore];\r\n    const newNodes = this.newNodesInContext(() => this.updater(this));\r\n\r\n    if (prevBranch === this.currentBranch) {\r\n      // ---- Same condition return\r\n      [this.willUnmountScopedStore, this.didUnmountScopedStore] = prevFuncs;\r\n      for (let i = 0; i < this.nodes!.length; i++) {\r\n        update(this.nodes![i]);\r\n      }\r\n      return;\r\n    }\r\n    const newFuncs = [this.willUnmountScopedStore, this.didUnmountScopedStore];\r\n    [this.willUnmountScopedStore, this.didUnmountScopedStore] = prevFuncs;\r\n    if (this.nodes && this.nodes.length > 0) {\r\n      this.removeNodes(this.nodes);\r\n    }\r\n    [this.willUnmountScopedStore, this.didUnmountScopedStore] = newFuncs;\r\n\r\n    this.nodes = newNodes;\r\n    if (this.nodes.length === 0) return;\r\n\r\n    // ---- Faster append with nextSibling rather than flowIndex\r\n    const flowIndex = getFlowIndexFromNodes(this.parentEl!.nodes!, this);\r\n    const nextSibling = this.parentEl!.childNodes[flowIndex];\r\n\r\n    appendNodesWithSibling(this.nodes, this.parentEl!, nextSibling);\r\n    init(this.nodes!);\r\n\r\n    runDidMount();\r\n  }\r\n}\r\n\r\nexport const createConditionalNode = (updater: (node: ConditionalNode) => InulaBaseNode[], reactBits: Bits) => {\r\n  return new ConditionalNode(updater, reactBits);\r\n};\r\n","import { InulaNodeType } from '../../consts';\r\nimport { addWillUnmount, addDidUnmount, runDidMount } from '../../lifecycle';\r\nimport { InulaStore } from '../../store';\r\nimport { Bits, InulaBaseNode, Value } from '../../types';\r\nimport { enterCompNode, getCurrentCompNode, leaveCompNode } from '../CompNode/node';\r\nimport {\r\n  appendNodesWithIndex,\r\n  appendNodesWithSibling,\r\n  arrayEqual,\r\n  getFlowIndexFromNodes,\r\n  insertNodesBefore,\r\n  toDOMElements,\r\n  update,\r\n} from '../utils';\r\nimport { MutableContextNode } from './context';\r\n\r\ntype ForNodeFunc = (\r\n  node: ForNode,\r\n  updateItemFuncArr: UpdateItemFunc[],\r\n  item: Value,\r\n  key: Value,\r\n  idx: number\r\n) => InulaBaseNode[];\r\ntype UpdateItemFunc = (item: Value, idx: number) => void;\r\n\r\n// TODO For node with only one child node\r\n\r\nclass ForNode extends MutableContextNode implements InulaBaseNode {\r\n  inulaType = InulaNodeType.For;\r\n\r\n  dataReactBits: Bits;\r\n\r\n  nodesMap = new Map();\r\n\r\n  nodeFunc;\r\n\r\n  dataFunc;\r\n  data;\r\n\r\n  keysFunc;\r\n  keys?: Value[];\r\n\r\n  /**\r\n   * @brief Getter for nodes\r\n   */\r\n  cachedNodes?: InulaBaseNode[];\r\n  nodesDirty = true;\r\n  get nodes() {\r\n    if (!this.nodesDirty) return this.cachedNodes;\r\n    const nodes = [];\r\n    for (let idx = 0; idx < this.data.length; idx++) {\r\n      nodes.push(...this.nodesMap.get(this.keys?.[idx] ?? idx));\r\n    }\r\n    this.cachedNodes = nodes;\r\n    this.nodesDirty = false;\r\n    return nodes;\r\n  }\r\n\r\n  setNodesMap(key: Value, nodes: InulaBaseNode[]) {\r\n    this.nodesMap.set(key, nodes);\r\n    this.nodesDirty = true;\r\n  }\r\n\r\n  /**\r\n   * @brief Constructor, For type\r\n   * @param data\r\n   * @param nodeFunc\r\n   * @param keys\r\n   */\r\n  constructor(dataFunc: () => Value[], keysFunc: null | (() => Value[]), nodeFunc: ForNodeFunc, dataReactBits: Bits) {\r\n    super();\r\n    this.dataFunc = dataFunc;\r\n    this.keysFunc = keysFunc;\r\n    this.nodeFunc = nodeFunc;\r\n    this.data = [...dataFunc()];\r\n    if (keysFunc) this.keys = [...keysFunc()];\r\n    this.update();\r\n\r\n    this.dataReactBits = dataReactBits;\r\n  }\r\n\r\n  updateItemFuncArr: UpdateItemFunc[] = [];\r\n\r\n  /**\r\n   * @brief Update the view related to one item in the data\r\n   * @param nodes\r\n   * @param item\r\n   */\r\n  updateItem(idx: number, data: Value[]) {\r\n    // ---- The update function of ForNode's childNodes is stored in the first child node\r\n    this.updateItemFuncArr[idx]?.(data[idx], idx);\r\n    // ---- Update the nodes\r\n    for (const node of this.nodesMap.get(this.keys?.[idx] ?? idx)) {\r\n      update(node);\r\n    }\r\n  }\r\n\r\n  updateItems() {\r\n    for (let idx = 0; idx < this.data.length; idx++) {\r\n      this.updateItem(idx, this.data);\r\n    }\r\n  }\r\n\r\n  notInitialized? = true;\r\n  /**\r\n   * @brief Non-data update function\r\n   * @param changed\r\n   */\r\n  update() {\r\n    // TODO: extract\r\n    if (this.notInitialized) {\r\n      for (let idx = 0; idx < this.data.length; idx++) {\r\n        let item = this.data[idx];\r\n        this.initUnmountStore();\r\n        const key = this.keys?.[idx] ?? idx;\r\n        const nodes = this.nodeFunc(this, this.updateItemFuncArr, item, key, idx);\r\n        this.setNodesMap(key, nodes);\r\n        this.setUnmountMap(key);\r\n      }\r\n      // ---- For nested ForNode, the whole strategy is just like EnvStore\r\n      //      we use data of function data to create \"environment\", popping and pushing\r\n      addWillUnmount(this.runAllWillUnmount.bind(this));\r\n      addDidUnmount(this.runAllDidUnmount.bind(this));\r\n      delete this.notInitialized;\r\n\r\n      for (const nodes of this.nodesMap.values()) {\r\n        for (const node of nodes) {\r\n          update(node);\r\n        }\r\n      }\r\n      runDidMount();\r\n      return;\r\n    }\r\n\r\n    // ---- e.g. this.depNum -> 1110 changed-> 1010\r\n    //      ~this.depNum & changed -> ~1110 & 1010 -> 0000\r\n    //      no update because depNum contains all the changed\r\n    // ---- e.g. this.depNum -> 1110 changed-> 1101\r\n    //      ~this.depNum & changed -> ~1110 & 1101 -> 0001\r\n    //      update because depNum doesn't contain all the changed\r\n    if (!(~this.dataReactBits & this.owner.dirtyBits!)) {\r\n      this.updateArray();\r\n      return;\r\n    }\r\n    this.updateItems();\r\n  }\r\n\r\n  /**\r\n   * @brief Array-related update function\r\n   * @param newData\r\n   * @param newKeys\r\n   */\r\n  updateArray() {\r\n    if (this.keysFunc) {\r\n      this.updateWithKey();\r\n      return;\r\n    }\r\n    this.updateWithOutKey();\r\n  }\r\n\r\n  /**\r\n   * @brief Shortcut to generate new nodes with idx and key\r\n   */\r\n  getNewNodes(idx: number, key: Value, data: Value[], updateItemFuncArr?: UpdateItemFunc[]) {\r\n    this.initUnmountStore();\r\n    enterCompNode(this.owner);\r\n\r\n    const nodes = this.newNodesInContext(() =>\r\n      this.nodeFunc(this, updateItemFuncArr ?? this.updateItemFuncArr, data[idx], key, idx)\r\n    );\r\n    for (const node of nodes) {\r\n      update(node);\r\n    }\r\n\r\n    leaveCompNode();\r\n    this.setUnmountMap(key);\r\n    this.setNodesMap(key, nodes);\r\n    return nodes;\r\n  }\r\n\r\n  willUnmountMap = new Map();\r\n  didUnmountMap = new Map();\r\n\r\n  /**\r\n   * @brief Set the unmount map by getting the last unmount map from the global store\r\n   * @param key\r\n   */\r\n  setUnmountMap(key: Value) {\r\n    const willUnmountStore = InulaStore.global.WillUnmountScopedStore.pop();\r\n    if (willUnmountStore && willUnmountStore.length > 0) {\r\n      if (!this.willUnmountMap) this.willUnmountMap = new Map();\r\n      this.willUnmountMap.set(key, willUnmountStore);\r\n    }\r\n    const didUnmountStore = InulaStore.global.DidUnmountScopedStore.pop();\r\n    if (didUnmountStore && didUnmountStore.length > 0) {\r\n      if (!this.didUnmountMap) this.didUnmountMap = new Map();\r\n      this.didUnmountMap.set(key, didUnmountStore);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @brief Run all the unmount functions and clear the unmount map\r\n   */\r\n  runAllWillUnmount() {\r\n    if (!this.willUnmountMap || this.willUnmountMap.size === 0) return;\r\n    this.willUnmountMap.forEach(funcs => {\r\n      for (let i = 0; i < funcs.length; i++) funcs[i]?.();\r\n    });\r\n    this.willUnmountMap.clear();\r\n  }\r\n\r\n  /**\r\n   * @brief Run all the unmount functions and clear the unmount map\r\n   */\r\n  runAllDidUnmount() {\r\n    if (!this.didUnmountMap || this.didUnmountMap.size === 0) return;\r\n    this.didUnmountMap.forEach(funcs => {\r\n      for (let i = funcs.length - 1; i >= 0; i--) funcs[i]?.();\r\n    });\r\n    this.didUnmountMap.clear();\r\n  }\r\n\r\n  /**\r\n   * @brief Run the unmount functions of the given key\r\n   * @param key\r\n   */\r\n  runWillUnmount(key: Value) {\r\n    if (!this.willUnmountMap || this.willUnmountMap.size === 0) return;\r\n    const funcs = this.willUnmountMap.get(key);\r\n    if (!funcs) return;\r\n    for (let i = 0; i < funcs.length; i++) funcs[i]?.();\r\n    this.willUnmountMap.delete(key);\r\n  }\r\n\r\n  /**\r\n   * @brief Run the unmount functions of the given key\r\n   */\r\n  runDidUnmount(key: Value) {\r\n    if (!this.didUnmountMap || this.didUnmountMap.size === 0) return;\r\n    const funcs = this.didUnmountMap.get(key);\r\n    if (!funcs) return;\r\n    for (let i = funcs.length - 1; i >= 0; i--) funcs[i]?.();\r\n    this.didUnmountMap.delete(key);\r\n  }\r\n\r\n  /**\r\n   * @brief Remove nodes from parentEl and run willUnmount and didUnmount\r\n   * @param nodes\r\n   * @param key\r\n   */\r\n  removeNodesInLifeCycle(nodes: InulaBaseNode[], key: Value) {\r\n    this.runWillUnmount(key);\r\n    super.removeNodes(nodes);\r\n    this.runDidUnmount(key);\r\n    this.nodesMap.delete(key);\r\n  }\r\n\r\n  /**\r\n   * @brief Update the nodes without keys\r\n   * @param newData\r\n   */\r\n  updateWithOutKey() {\r\n    const newData = this.dataFunc();\r\n    const preLength = this.data.length;\r\n    const currLength = newData.length;\r\n\r\n    if (preLength === currLength) {\r\n      // ---- If the length is the same, we only need to update the nodes\r\n      for (let idx = 0; idx < this.data.length; idx++) {\r\n        this.updateItem(idx, newData);\r\n      }\r\n      this.data = [...newData];\r\n      return;\r\n    }\r\n    const parentEl = this.parentEl!;\r\n    // ---- If the new data is longer, add new nodes directly\r\n    if (preLength < currLength) {\r\n      let flowIndex = getFlowIndexFromNodes(parentEl.nodes!, this);\r\n      // ---- Calling parentEl.childNodes.length is time-consuming,\r\n      //      so we use a length variable to store the length\r\n      const length = parentEl.childNodes.length;\r\n      for (let idx = 0; idx < currLength; idx++) {\r\n        if (idx < preLength) {\r\n          flowIndex += getFlowIndexFromNodes(this.nodesMap.get(idx));\r\n          this.updateItem(idx, newData);\r\n          continue;\r\n        }\r\n        const newNodes = this.getNewNodes(idx, idx, newData);\r\n        appendNodesWithIndex(newNodes, parentEl, flowIndex, length);\r\n      }\r\n      runDidMount();\r\n      this.data = [...newData];\r\n      return;\r\n    }\r\n\r\n    // ---- Update the nodes first\r\n    for (let idx = 0; idx < currLength; idx++) {\r\n      this.updateItem(idx, newData);\r\n    }\r\n    // ---- If the new data is shorter, remove the extra nodes\r\n    for (let idx = currLength; idx < preLength; idx++) {\r\n      const nodes = this.nodesMap.get(idx);\r\n      this.removeNodesInLifeCycle(nodes, idx);\r\n    }\r\n    this.updateItemFuncArr.splice(currLength, preLength - currLength);\r\n    this.data = [...newData];\r\n  }\r\n\r\n  /**\r\n   * @brief Update the nodes with keys\r\n   * @param newData\r\n   * @param newKeys\r\n   */\r\n  updateWithKey() {\r\n    const newData = this.dataFunc();\r\n    const newKeys = this.keysFunc!();\r\n    if (newKeys.length !== new Set(newKeys).size) {\r\n      throw new Error('Inula: Duplicate keys in for loop are not allowed');\r\n    }\r\n    const prevKeys = this.keys!;\r\n    this.keys = newKeys;\r\n\r\n    if (arrayEqual(prevKeys, this.keys)) {\r\n      // ---- If the keys are the same, we only need to update the nodes\r\n      for (let idx = 0; idx < newData.length; idx++) {\r\n        this.updateItem(idx, newData);\r\n      }\r\n      this.data = [...newData];\r\n      return;\r\n    }\r\n\r\n    const parentEl = this.parentEl!;\r\n\r\n    // ---- No nodes after, delete all nodes\r\n    if (this.keys.length === 0) {\r\n      const parentNodes = parentEl.nodes ?? [];\r\n      if (parentNodes.length === 1 && parentNodes[0] === this) {\r\n        // ---- ForNode is the only node in the parent node\r\n        //      Frequently used in real life scenarios because we tend to always wrap for with a div element,\r\n        //      so we optimize it here\r\n        this.runAllWillUnmount();\r\n        parentEl.innerHTML = '';\r\n        this.runAllDidUnmount();\r\n      } else {\r\n        for (let prevIdx = 0; prevIdx < prevKeys.length; prevIdx++) {\r\n          const prevKey = prevKeys[prevIdx];\r\n          this.removeNodesInLifeCycle(this.nodesMap.get(prevKey), prevKey);\r\n        }\r\n      }\r\n      this.nodesMap.clear();\r\n      this.updateItemFuncArr = [];\r\n      this.data = [];\r\n      return;\r\n    }\r\n\r\n    // ---- Record how many nodes are before this ForNode with the same parentNode\r\n    const flowIndex = getFlowIndexFromNodes(parentEl.nodes!, this);\r\n\r\n    // ---- No nodes before, append all nodes\r\n    if (prevKeys.length === 0) {\r\n      const nextSibling = parentEl.childNodes[flowIndex];\r\n      for (let idx = 0; idx < this.keys.length; idx++) {\r\n        const newNodes = this.getNewNodes(idx, this.keys[idx], newData);\r\n        appendNodesWithSibling(newNodes, parentEl, nextSibling);\r\n      }\r\n      runDidMount();\r\n      this.data = [...newData];\r\n      return;\r\n    }\r\n\r\n    const shuffleKeys = [];\r\n    const newUpdateArr = [];\r\n\r\n    // ---- 1. Delete the nodes that are no longer in the data\r\n    for (let prevIdx = 0; prevIdx < prevKeys.length; prevIdx++) {\r\n      const prevKey = prevKeys[prevIdx];\r\n      if (this.keys.includes(prevKey)) {\r\n        shuffleKeys.push(prevKey);\r\n        newUpdateArr.push(this.updateItemFuncArr[prevIdx]);\r\n        continue;\r\n      }\r\n      this.removeNodesInLifeCycle(this.nodesMap.get(prevKey), prevKey);\r\n    }\r\n\r\n    // ---- 2. Add the nodes that are not in the data but in the new data\r\n    // ---- Calling parentEl.childNodes.length is time-consuming,\r\n    //      so we use a length variable to store the length\r\n    let length = parentEl.childNodes.length;\r\n    let newFlowIndex = flowIndex;\r\n    for (let idx = 0; idx < this.keys.length; idx++) {\r\n      const key = this.keys[idx];\r\n      const prevIdx = shuffleKeys.indexOf(key);\r\n      if (prevIdx !== -1) {\r\n        // ---- These nodes are already in the parentEl,\r\n        //      and we need to keep track of their flowIndex\r\n        newFlowIndex += getFlowIndexFromNodes(this.nodesMap.get(key));\r\n        newUpdateArr[prevIdx]?.(this.owner.dirtyBits, newData[idx]);\r\n        continue;\r\n      }\r\n      // ---- Insert updateItemFuncArr first because in getNewNode the updateFunc will replace this null\r\n      newUpdateArr.splice(idx, 0, null as Value);\r\n      const newNodes = this.getNewNodes(idx, key, newData, newUpdateArr);\r\n      // ---- Add the new nodes\r\n      shuffleKeys.splice(idx, 0, key);\r\n\r\n      const count = appendNodesWithIndex(newNodes, parentEl, newFlowIndex, length);\r\n      newFlowIndex += count;\r\n      length += count;\r\n    }\r\n    runDidMount();\r\n\r\n    // ---- After adding and deleting, the only thing left is to reorder the nodes,\r\n    //      but if the keys are the same, we don't need to reorder\r\n    if (arrayEqual(this.keys, shuffleKeys)) {\r\n      this.data = [...newData];\r\n      this.updateItemFuncArr = newUpdateArr;\r\n      return;\r\n    }\r\n\r\n    newFlowIndex = flowIndex;\r\n    const bufferNodes = new Map();\r\n    // ---- 3. Replace the nodes in the same position using Fisher-Yates shuffle algorithm\r\n    for (let idx = 0; idx < this.keys.length; idx++) {\r\n      const key = this.keys[idx];\r\n      const prevIdx = shuffleKeys.indexOf(key);\r\n\r\n      const bufferedNode = bufferNodes.get(key);\r\n      if (bufferedNode) {\r\n        // ---- We need to add the flowIndex of the bufferedNode,\r\n        //      because the bufferedNode is in the parentEl and the new position is ahead of the previous position\r\n        const bufferedFlowIndex = getFlowIndexFromNodes(bufferedNode);\r\n        const lastEl = toDOMElements(bufferedNode).pop();\r\n        const nextSibling = parentEl.childNodes[newFlowIndex + bufferedFlowIndex];\r\n        if (lastEl !== nextSibling && lastEl!.nextSibling !== nextSibling) {\r\n          // ---- If the node is buffered, we need to add it to the parentEl\r\n          insertNodesBefore(bufferedNode, parentEl, nextSibling);\r\n        }\r\n        // ---- So the added length is the length of the bufferedNode\r\n        newFlowIndex += bufferedFlowIndex;\r\n        bufferNodes.delete(key);\r\n      } else if (prevIdx === idx) {\r\n        // ---- If the node is in the same position, we don't need to do anything\r\n        newFlowIndex += getFlowIndexFromNodes(this.nodesMap.get(key));\r\n        continue;\r\n      } else {\r\n        // ---- If the node is not in the same position, we need to buffer it\r\n        //      We buffer the node of the previous position, and then replace it with the node of the current position\r\n        const prevKey = shuffleKeys[idx];\r\n        bufferNodes.set(prevKey, this.nodesMap.get(prevKey));\r\n        // ---- Length would never change, and the last will always be in the same position,\r\n        //      so it'll always be insertBefore instead of appendChild\r\n        const childNodes = this.nodesMap.get(key);\r\n        const lastEl = toDOMElements(childNodes).pop();\r\n        const nextSibling = parentEl.childNodes[newFlowIndex];\r\n        if (lastEl !== nextSibling && lastEl!.nextSibling !== nextSibling) {\r\n          newFlowIndex += insertNodesBefore(childNodes, parentEl, nextSibling);\r\n        }\r\n      }\r\n      // ---- Swap the keys\r\n      const tempKey: Value = shuffleKeys[idx];\r\n      shuffleKeys[idx] = shuffleKeys[prevIdx];\r\n      shuffleKeys[prevIdx] = tempKey;\r\n      const tempUpdateFunc: UpdateItemFunc = newUpdateArr[idx];\r\n      newUpdateArr[idx] = newUpdateArr[prevIdx];\r\n      newUpdateArr[prevIdx] = tempUpdateFunc;\r\n    }\r\n    this.data = [...newData];\r\n    this.updateItemFuncArr = newUpdateArr;\r\n  }\r\n}\r\n\r\nexport const createForNode = (\r\n  dataFunc: () => Value[],\r\n  keysFunc: null | (() => Value[]),\r\n  nodeFunc: ForNodeFunc,\r\n  dataReactBits: Bits\r\n) => {\r\n  return new ForNode(dataFunc, keysFunc, nodeFunc, dataReactBits);\r\n};\r\n","import { InulaNodeType } from '../../consts';\r\nimport { runDidMount } from '../../lifecycle';\r\nimport { Bits, InulaBaseNode, Value } from '../../types';\r\nimport { appendNodesWithSibling, cached, getFlowIndexFromNodes, init } from '../utils';\r\nimport { MutableLifecycleNode } from './lifecycle';\r\nimport { createTextNode } from '../HTMLNode';\r\n\r\nclass ExpNode extends MutableLifecycleNode implements InulaBaseNode {\r\n  inulaType = InulaNodeType.Cond;\r\n\r\n  nodes?: InulaBaseNode[];\r\n\r\n  updater;\r\n\r\n  reactBits: Bits;\r\n\r\n  dependenciesFunc: () => Value[];\r\n  cachedDeps?: Value[];\r\n\r\n  constructor(updater: () => Value, dependenciesFunc: () => Value[], reactBits: Bits) {\r\n    super();\r\n    this.updater = updater;\r\n    this.reactBits = reactBits;\r\n    this.dependenciesFunc = dependenciesFunc;\r\n    this.initUnmountStore();\r\n    this.nodes = this.getExpressionResult();\r\n    this.setUnmountFuncs();\r\n  }\r\n\r\n  update() {\r\n    if (!(this.reactBits & this.owner.dirtyBits!)) return;\r\n    if (cached(this.dependenciesFunc(), this.cachedDeps)) return;\r\n    const prevFuncs = [this.willUnmountScopedStore, this.didUnmountScopedStore];\r\n    const newNodes = this.newNodesInContext(() => this.getExpressionResult());\r\n\r\n    const newFuncs = [this.willUnmountScopedStore, this.didUnmountScopedStore];\r\n    [this.willUnmountScopedStore, this.didUnmountScopedStore] = prevFuncs;\r\n    if (this.nodes && this.nodes.length > 0) {\r\n      this.removeNodes(this.nodes);\r\n    }\r\n    [this.willUnmountScopedStore, this.didUnmountScopedStore] = newFuncs;\r\n\r\n    this.nodes = newNodes;\r\n    if (this.nodes.length === 0) return;\r\n\r\n    // ---- Faster append with nextSibling rather than flowIndex\r\n    const flowIndex = getFlowIndexFromNodes(this.parentEl!.nodes!, this);\r\n    const nextSibling = this.parentEl!.childNodes[flowIndex];\r\n\r\n    appendNodesWithSibling(this.nodes, this.parentEl!, nextSibling);\r\n    init(this.nodes!);\r\n\r\n    runDidMount();\r\n  }\r\n\r\n  getExpressionResult() {\r\n    let nodes = this.updater();\r\n    if (!Array.isArray(nodes)) nodes = [nodes];\r\n    return nodes\r\n      .flat(1)\r\n      .map((node: Value) => {\r\n        if (typeof node === 'string' || typeof node === 'number' || typeof node === 'bigint') {\r\n          // TODO DO\r\n          return createTextNode(`${node}`, () => {});\r\n        }\r\n        if (typeof node === 'function' && node.$$isChildren) {\r\n          return node();\r\n        }\r\n        return node;\r\n      })\r\n      .flat(1)\r\n      .filter((node: Value) => node !== undefined && node !== null && typeof node !== 'boolean');\r\n  }\r\n}\r\n\r\nexport const createExpNode = (updater: () => Value, dependenciesFunc: () => Value[], reactBits: Bits) => {\r\n  return new ExpNode(updater, dependenciesFunc, reactBits);\r\n};\r\n","export function watch(effect: () => void) {\r\n  throw new Error('Watch should not be called directly, please check the docs for more information');\r\n}\r\n\r\nexport function didMount(effect: () => void) {\r\n  throw new Error('DidMount should not be called directly, please check the docs for more information');\r\n}\r\n\r\nexport function willUnmount(effect: () => void) {\r\n  throw new Error('WillUnmount should not be called directly, please check the docs for more information');\r\n}\r\n\r\nexport function didUnmount(effect: () => void) {\r\n  throw new Error('DidUnmount should not be called directly, please check the docs for more information');\r\n}\r\n"],"mappings":"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","names":["update","update","_update","newNodes"]}