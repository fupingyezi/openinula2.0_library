var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name2, symbol) => (symbol = Symbol[name2]) ? symbol : Symbol.for("Symbol." + name2);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")], isAwait = false, method, it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw") throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object)) __typeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};

// ../../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports, module) {
    "use strict";
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m) return [str];
      var pre = m.pre;
      var post = m.post.length ? expand2(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand2(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand2(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand2(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// ../../../node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js
var require_lib = __commonJS({
  "../../../node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.declare = declare;
    exports.declarePreset = void 0;
    var apiPolyfills = {
      assertVersion: (api) => (range) => {
        throwVersionError(range, api.version);
      }
    };
    {
      Object.assign(apiPolyfills, {
        targets: () => () => {
          return {};
        },
        assumption: () => () => {
          return void 0;
        },
        addExternalDependency: () => () => {
        }
      });
    }
    function declare(builder) {
      return (api, options, dirname) => {
        var _clonedApi2;
        let clonedApi;
        for (const name2 of Object.keys(apiPolyfills)) {
          var _clonedApi;
          if (api[name2]) continue;
          (_clonedApi = clonedApi) != null ? _clonedApi : clonedApi = copyApiObject(api);
          clonedApi[name2] = apiPolyfills[name2](clonedApi);
        }
        return builder((_clonedApi2 = clonedApi) != null ? _clonedApi2 : api, options || {}, dirname);
      };
    }
    var declarePreset = exports.declarePreset = declare;
    function copyApiObject(api) {
      let proto = null;
      if (typeof api.version === "string" && /^7\./.test(api.version)) {
        proto = Object.getPrototypeOf(api);
        if (proto && (!hasOwnProperty.call(proto, "version") || !hasOwnProperty.call(proto, "transform") || !hasOwnProperty.call(proto, "template") || !hasOwnProperty.call(proto, "types"))) {
          proto = null;
        }
      }
      return Object.assign({}, proto, api);
    }
    function throwVersionError(range, version) {
      if (typeof range === "number") {
        if (!Number.isInteger(range)) {
          throw new Error("Expected string or integer value.");
        }
        range = `^${range}.0.0-0`;
      }
      if (typeof range !== "string") {
        throw new Error("Expected string or integer value.");
      }
      const limit = Error.stackTraceLimit;
      if (typeof limit === "number" && limit < 25) {
        Error.stackTraceLimit = 25;
      }
      let err;
      if (version.slice(0, 2) === "7.") {
        err = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${version}". You'll need to update your @babel/core version.`);
      } else {
        err = new Error(`Requires Babel "${range}", but was loaded with "${version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
      }
      if (typeof limit === "number") {
        Error.stackTraceLimit = limit;
      }
      throw Object.assign(err, {
        code: "BABEL_VERSION_UNSUPPORTED",
        version,
        range
      });
    }
  }
});

// ../../../node_modules/.pnpm/@babel+plugin-syntax-jsx@7.23.3_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-jsx/lib/index.js
var require_lib2 = __commonJS({
  "../../../node_modules/.pnpm/@babel+plugin-syntax-jsx@7.23.3_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-jsx/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _helperPluginUtils = require_lib();
    var _default = exports.default = (0, _helperPluginUtils.declare)((api) => {
      api.assertVersion(7);
      return {
        name: "syntax-jsx",
        manipulateOptions(opts, parserOpts) {
          {
            if (parserOpts.plugins.some((p) => (Array.isArray(p) ? p[0] : p) === "typescript")) {
              return;
            }
          }
          parserOpts.plugins.push("jsx");
        }
      };
    });
  }
});

// ../../../node_modules/.pnpm/@babel+plugin-syntax-typescript@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-typescript/lib/index.js
var require_lib3 = __commonJS({
  "../../../node_modules/.pnpm/@babel+plugin-syntax-typescript@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-typescript/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _helperPluginUtils = require_lib();
    {
      removePlugin = function(plugins, name2) {
        const indices = [];
        plugins.forEach((plugin, i) => {
          const n = Array.isArray(plugin) ? plugin[0] : plugin;
          if (n === name2) {
            indices.unshift(i);
          }
        });
        for (const i of indices) {
          plugins.splice(i, 1);
        }
      };
    }
    var removePlugin;
    var _default = exports.default = (0, _helperPluginUtils.declare)((api, opts) => {
      api.assertVersion(7);
      const {
        disallowAmbiguousJSXLike,
        dts
      } = opts;
      {
        var {
          isTSX
        } = opts;
      }
      return {
        name: "syntax-typescript",
        manipulateOptions(opts2, parserOpts) {
          {
            const {
              plugins
            } = parserOpts;
            removePlugin(plugins, "flow");
            removePlugin(plugins, "jsx");
            {
              plugins.push("objectRestSpread", "classProperties");
            }
            if (isTSX) {
              plugins.push("jsx");
            }
          }
          parserOpts.plugins.push(["typescript", {
            disallowAmbiguousJSXLike,
            dts
          }]);
        }
      };
    });
  }
});

// ../../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/index.js
var import_brace_expansion = __toESM(require_brace_expansion(), 1);

// ../../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// ../../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position) => {
  const pos = position;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE: while (i < glob.length) {
    const c = glob.charAt(i);
    if ((c === "!" || c === "^") && i === pos + 1) {
      negate = true;
      i++;
      continue;
    }
    if (c === "]" && sawStart && !escaping) {
      endPos = i + 1;
      break;
    }
    sawStart = true;
    if (c === "\\") {
      if (!escaping) {
        escaping = true;
        i++;
        continue;
      }
    }
    if (c === "[" && !escaping) {
      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
        if (glob.startsWith(cls, i)) {
          if (rangeStart) {
            return ["$.", false, glob.length - pos, true];
          }
          i += cls.length;
          if (neg)
            negs.push(unip);
          else
            ranges.push(unip);
          uflag = uflag || u;
          continue WHILE;
        }
      }
    }
    escaping = false;
    if (rangeStart) {
      if (c > rangeStart) {
        ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
      } else if (c === rangeStart) {
        ranges.push(braceEscape(c));
      }
      rangeStart = "";
      i++;
      continue;
    }
    if (glob.startsWith("-]", i + 1)) {
      ranges.push(braceEscape(c + "-"));
      i += 2;
      continue;
    }
    if (glob.startsWith("-", i + 1)) {
      rangeStart = c;
      i += 2;
      continue;
    }
    ranges.push(braceEscape(c));
    i++;
  }
  if (endPos < i) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// ../../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/unescape.js
var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// ../../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c) => types.has(c);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _AST_instances, fillNegs_fn, _AST_static, parseAST_fn, partsToRegExp_fn, parseGlob_fn;
var _AST = class _AST {
  constructor(type, parent, options = {}) {
    __privateAdd(this, _AST_instances);
    __publicField(this, "type");
    __privateAdd(this, _root);
    __privateAdd(this, _hasMagic);
    __privateAdd(this, _uflag, false);
    __privateAdd(this, _parts, []);
    __privateAdd(this, _parent);
    __privateAdd(this, _parentIndex);
    __privateAdd(this, _negs);
    __privateAdd(this, _filledNegs, false);
    __privateAdd(this, _options);
    __privateAdd(this, _toString);
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    __privateAdd(this, _emptyExt, false);
    this.type = type;
    if (type)
      __privateSet(this, _hasMagic, true);
    __privateSet(this, _parent, parent);
    __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this);
    __privateSet(this, _options, __privateGet(this, _root) === this ? options : __privateGet(__privateGet(this, _root), _options));
    __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs));
    if (type === "!" && !__privateGet(__privateGet(this, _root), _filledNegs))
      __privateGet(this, _negs).push(this);
    __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
  }
  get hasMagic() {
    if (__privateGet(this, _hasMagic) !== void 0)
      return __privateGet(this, _hasMagic);
    for (const p of __privateGet(this, _parts)) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return __privateSet(this, _hasMagic, true);
    }
    return __privateGet(this, _hasMagic);
  }
  // reconstructs the pattern
  toString() {
    if (__privateGet(this, _toString) !== void 0)
      return __privateGet(this, _toString);
    if (!this.type) {
      return __privateSet(this, _toString, __privateGet(this, _parts).map((p) => String(p)).join(""));
    } else {
      return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((p) => String(p)).join("|") + ")");
    }
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof _AST && __privateGet(p, _parent) === this)) {
        throw new Error("invalid part: " + p);
      }
      __privateGet(this, _parts).push(p);
    }
  }
  toJSON() {
    var _a2;
    const ret = this.type === null ? __privateGet(this, _parts).slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...__privateGet(this, _parts).map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && ((_a2 = __privateGet(this, _parent)) == null ? void 0 : _a2.type) === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    var _a2;
    if (__privateGet(this, _root) === this)
      return true;
    if (!((_a2 = __privateGet(this, _parent)) == null ? void 0 : _a2.isStart()))
      return false;
    if (__privateGet(this, _parentIndex) === 0)
      return true;
    const p = __privateGet(this, _parent);
    for (let i = 0; i < __privateGet(this, _parentIndex); i++) {
      const pp = __privateGet(p, _parts)[i];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    var _a2, _b, _c;
    if (__privateGet(this, _root) === this)
      return true;
    if (((_a2 = __privateGet(this, _parent)) == null ? void 0 : _a2.type) === "!")
      return true;
    if (!((_b = __privateGet(this, _parent)) == null ? void 0 : _b.isEnd()))
      return false;
    if (!this.type)
      return (_c = __privateGet(this, _parent)) == null ? void 0 : _c.isEnd();
    const pl = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
    return __privateGet(this, _parentIndex) === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c = new _AST(this.type, parent);
    for (const p of __privateGet(this, _parts)) {
      c.copyIn(p);
    }
    return c;
  }
  static fromGlob(pattern, options = {}) {
    var _a2;
    const ast = new _AST(null, void 0, options);
    __privateMethod(_a2 = _AST, _AST_static, parseAST_fn).call(_a2, pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== __privateGet(this, _root))
      return __privateGet(this, _root).toMMPattern();
    const glob = this.toString();
    const [re, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob
    });
  }
  get options() {
    return __privateGet(this, _options);
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    var _a2;
    const dot = allowDot != null ? allowDot : !!__privateGet(this, _options).dot;
    if (__privateGet(this, _root) === this)
      __privateMethod(this, _AST_instances, fillNegs_fn).call(this);
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = __privateGet(this, _parts).map((p) => {
        var _a3;
        const [re, _, hasMagic, uflag] = typeof p === "string" ? __privateMethod(_a3 = _AST, _AST_static, parseGlob_fn).call(_a3, p, __privateGet(this, _hasMagic), noEmpty) : p.toRegExpSource(allowDot);
        __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic);
        __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof __privateGet(this, _parts)[0] === "string") {
          const dotTravAllowed = __privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && ((_a2 = __privateGet(this, _parent)) == null ? void 0 : _a2.type) === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape(src),
        __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
        __privateGet(this, _uflag)
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s = this.toString();
      __privateSet(this, _parts, [s]);
      this.type = null;
      __privateSet(this, _hasMagic, void 0);
      return [s, unescape(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && __privateGet(this, _emptyExt)) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape(body),
      __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
      __privateGet(this, _uflag)
    ];
  }
};
_root = new WeakMap();
_hasMagic = new WeakMap();
_uflag = new WeakMap();
_parts = new WeakMap();
_parent = new WeakMap();
_parentIndex = new WeakMap();
_negs = new WeakMap();
_filledNegs = new WeakMap();
_options = new WeakMap();
_toString = new WeakMap();
_emptyExt = new WeakMap();
_AST_instances = new WeakSet();
fillNegs_fn = function() {
  if (this !== __privateGet(this, _root))
    throw new Error("should only call on root");
  if (__privateGet(this, _filledNegs))
    return this;
  this.toString();
  __privateSet(this, _filledNegs, true);
  let n;
  while (n = __privateGet(this, _negs).pop()) {
    if (n.type !== "!")
      continue;
    let p = n;
    let pp = __privateGet(p, _parent);
    while (pp) {
      for (let i = __privateGet(p, _parentIndex) + 1; !pp.type && i < __privateGet(pp, _parts).length; i++) {
        for (const part of __privateGet(n, _parts)) {
          if (typeof part === "string") {
            throw new Error("string part in extglob AST??");
          }
          part.copyIn(__privateGet(pp, _parts)[i]);
        }
      }
      p = pp;
      pp = __privateGet(p, _parent);
    }
  }
  return this;
};
_AST_static = new WeakSet();
parseAST_fn = function(str, ast, pos, opt) {
  var _a2, _b;
  let escaping = false;
  let inBrace = false;
  let braceStart = -1;
  let braceNeg = false;
  if (ast.type === null) {
    let i2 = pos;
    let acc2 = "";
    while (i2 < str.length) {
      const c = str.charAt(i2++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc2 += c;
        continue;
      }
      if (inBrace) {
        if (i2 === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc2 += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i2;
        braceNeg = false;
        acc2 += c;
        continue;
      }
      if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
        ast.push(acc2);
        acc2 = "";
        const ext2 = new _AST(c, ast);
        i2 = __privateMethod(_a2 = _AST, _AST_static, parseAST_fn).call(_a2, str, ext2, i2, opt);
        ast.push(ext2);
        continue;
      }
      acc2 += c;
    }
    ast.push(acc2);
    return i2;
  }
  let i = pos + 1;
  let part = new _AST(null, ast);
  const parts = [];
  let acc = "";
  while (i < str.length) {
    const c = str.charAt(i++);
    if (escaping || c === "\\") {
      escaping = !escaping;
      acc += c;
      continue;
    }
    if (inBrace) {
      if (i === braceStart + 1) {
        if (c === "^" || c === "!") {
          braceNeg = true;
        }
      } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
        inBrace = false;
      }
      acc += c;
      continue;
    } else if (c === "[") {
      inBrace = true;
      braceStart = i;
      braceNeg = false;
      acc += c;
      continue;
    }
    if (isExtglobType(c) && str.charAt(i) === "(") {
      part.push(acc);
      acc = "";
      const ext2 = new _AST(c, part);
      part.push(ext2);
      i = __privateMethod(_b = _AST, _AST_static, parseAST_fn).call(_b, str, ext2, i, opt);
      continue;
    }
    if (c === "|") {
      part.push(acc);
      acc = "";
      parts.push(part);
      part = new _AST(null, ast);
      continue;
    }
    if (c === ")") {
      if (acc === "" && __privateGet(ast, _parts).length === 0) {
        __privateSet(ast, _emptyExt, true);
      }
      part.push(acc);
      acc = "";
      ast.push(...parts, part);
      return i;
    }
    acc += c;
  }
  ast.type = null;
  __privateSet(ast, _hasMagic, void 0);
  __privateSet(ast, _parts, [str.substring(pos - 1)]);
  return i;
};
partsToRegExp_fn = function(dot) {
  return __privateGet(this, _parts).map((p) => {
    if (typeof p === "string") {
      throw new Error("string type in extglob ast??");
    }
    const [re, _, _hasMagic2, uflag] = p.toRegExpSource(dot);
    __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
    return re;
  }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
};
parseGlob_fn = function(glob, hasMagic, noEmpty = false) {
  let escaping = false;
  let re = "";
  let uflag = false;
  for (let i = 0; i < glob.length; i++) {
    const c = glob.charAt(i);
    if (escaping) {
      escaping = false;
      re += (reSpecials.has(c) ? "\\" : "") + c;
      continue;
    }
    if (c === "\\") {
      if (i === glob.length - 1) {
        re += "\\\\";
      } else {
        escaping = true;
      }
      continue;
    }
    if (c === "[") {
      const [src, needUflag, consumed, magic] = parseClass(glob, i);
      if (consumed) {
        re += src;
        uflag = uflag || needUflag;
        i += consumed - 1;
        hasMagic = hasMagic || magic;
        continue;
      }
    }
    if (c === "*") {
      if (noEmpty && glob === "*")
        re += starNoEmpty;
      else
        re += star;
      hasMagic = true;
      continue;
    }
    if (c === "?") {
      re += qmark;
      hasMagic = true;
      continue;
    }
    re += regExpEscape(c);
  }
  return [re, unescape(glob), !!hasMagic, uflag];
};
__privateAdd(_AST, _AST_static);
var AST = _AST;

// ../../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/escape.js
var escape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
};

// ../../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/index.js
var minimatch = (p, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => f.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f) => f.length !== 0 && !f.startsWith(".");
var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
var ext = (a, b = {}) => Object.assign({}, a, b);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
    escape: (s, options = {}) => orig.escape(s, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return (0, import_brace_expansion.default)(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter((f) => mm.match(f));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  constructor(pattern, options = {}) {
    __publicField(this, "options");
    __publicField(this, "set");
    __publicField(this, "pattern");
    __publicField(this, "windowsPathsNoEscape");
    __publicField(this, "nonegate");
    __publicField(this, "negate");
    __publicField(this, "comment");
    __publicField(this, "empty");
    __publicField(this, "preserveMultipleSlashes");
    __publicField(this, "partial");
    __publicField(this, "globSet");
    __publicField(this, "globParts");
    __publicField(this, "nocase");
    __publicField(this, "isWindows");
    __publicField(this, "platform");
    __publicField(this, "windowsNoMagicRoot");
    __publicField(this, "regexp");
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
        const isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC) {
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s) => s.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i = 0; i < this.set.length; i++) {
        const p = this.set[i];
        if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i = 0; i < globParts.length; i++) {
        for (let j = 0; j < globParts[i].length; j++) {
          if (globParts[i][j] === "**") {
            globParts[i][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i = gs;
        while (parts[i + 1] === "**") {
          i++;
        }
        if (i !== gs) {
          parts.splice(gs, i - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i = 1; i < parts.length - 1; i++) {
          const p = parts[i];
          if (i === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i, 1);
            i--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p = parts[dd - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p = parts[gs + 2];
          const p2 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i = 0; i < globParts.length - 1; i++) {
      for (let j = i + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i] = [];
          globParts[j] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a, b, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a.length && bi < b.length) {
      if (a[ai] === b[bi]) {
        result.push(which === "b" ? b[bi] : a[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
        result.push(a[ai]);
        ai++;
      } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
        result.push(b[bi]);
        bi++;
      } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a[ai]);
        ai++;
        bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = p.test(f);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set.map((pattern) => {
      const pp = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f of p.flags.split(""))
            flags.add(f);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp.forEach((p, i) => {
        const next = pp[i + 1];
        const prev = pp[i - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i] = twoStar;
          }
        } else if (next === void 0) {
          pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p) => p !== GLOBSTAR).join("/");
    }).join("|");
    const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f, partial = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f === "";
    }
    if (f === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f = f.split("\\").join("/");
    }
    const ff = this.slashSplit(f);
    this.debug(this.pattern, "split", ff);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i = ff.length - 2; !filename && i >= 0; i--) {
        filename = ff[i];
      }
    }
    for (let i = 0; i < set.length; i++) {
      const pattern = set[i];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// ../babel-inula-next-core/dist/index.js
var import_plugin_syntax_jsx = __toESM(require_lib2(), 1);
var import_plugin_syntax_typescript = __toESM(require_lib3(), 1);

// ../babel-api/src/index.mjs
var _t = null;
var babelApi = null;
var register = (api) => {
  babelApi = api;
  _t = api.types;
};
var getBabelApi = () => {
  if (!babelApi) {
    throw new Error("Please call register() before using the babel api");
  }
  return babelApi;
};
function traverse(node, visitor) {
  getBabelApi().traverse(node, visitor);
}
var types2 = new Proxy(
  {},
  {
    get: (_, p, receiver) => {
      if (!_t) {
        throw new Error("Please call register() before using the babel types");
      }
      if (p in _t) {
        return Reflect.get(_t, p, receiver);
      }
      return void 0;
    }
  }
);

// ../error-handler/dist/index.js
function createErrorHandler(errorSpace, throwMap = {}, errorMap = {}, warningMap = {}) {
  function handleError(map, type, func) {
    return Object.fromEntries(
      Object.entries(map).map(([code, msg]) => [
        `${type}${code}`,
        (...args) => {
          args.forEach((arg, i) => {
            msg = msg.replace(`$${i}`, arg);
          });
          return func(`:D - ${errorSpace}[${type}${code}]: ${msg}`);
        }
      ])
    );
  }
  const methods = __spreadValues(__spreadValues(__spreadValues({}, handleError(throwMap, "throw", (msg) => {
    throw new Error(msg);
  })), handleError(errorMap, "error", console.error)), handleError(warningMap, "warn", console.warn));
  function notDescribed(type) {
    return () => `:D ${errorSpace}: ${type} not described`;
  }
  return __spreadProps(__spreadValues({}, methods), {
    throwUnknown: notDescribed("throw"),
    errorUnknown: notDescribed("error"),
    warnUnknown: notDescribed("warn")
  });
}
var CompilerError = class extends Error {
  constructor(message, loc, suggestion) {
    super(message);
    this.message = message;
    this.loc = loc;
    this.suggestion = suggestion;
  }
  static invariant(condition, message, loc, suggestion) {
    if (!condition) {
      throw new CompilerError(message, loc, suggestion);
    }
  }
};

// ../reactivity-parser/dist/index.js
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var DLError = createErrorHandler("ReactivityParser", {
  1: "Invalid ViewUnit type"
});
function getDependenciesFromNode(node, reactiveBitMap, reactivityFuncNames2) {
  let readingBits = 0;
  let writingBits = 0;
  const depNodes = {};
  const wrappedNode = valueWrapper(node);
  getBabelApi().traverse(wrappedNode, {
    Identifier: (innerPath) => {
      const reactiveName = innerPath.node.name;
      const bit = reactiveBitMap.get(reactiveName);
      if (bit !== void 0) {
        if (isAssignmentExpressionLeft(innerPath) || isAssignmentFunction(innerPath, reactivityFuncNames2)) {
          writingBits |= bit;
        } else if (isStandAloneIdentifier(innerPath) && !isMemberInUntrackFunction(innerPath)) {
          readingBits |= bit;
          if (!depNodes[reactiveName])
            depNodes[reactiveName] = [];
          depNodes[reactiveName].push(geneDependencyNode(innerPath));
        }
      }
    }
  });
  preventSelfMutation(writingBits & readingBits, reactiveBitMap, node);
  if (readingBits === 0)
    return null;
  let dependencyNodes = Object.values(depNodes).flat();
  dependencyNodes = dependencyNodes.filter((n, i) => {
    const idx = dependencyNodes.findIndex((m) => types2.isNodesEquivalent(m, n));
    return idx === i;
  });
  return {
    dependenciesNode: types2.arrayExpression(dependencyNodes),
    depIdBitmap: readingBits
  };
}
function preventSelfMutation(overlapBits, reactiveBitMap, node) {
  if (overlapBits !== 0) {
    const cyclicDependencies = [];
    Array.from(reactiveBitMap.entries()).forEach(([name2, bit]) => {
      if (overlapBits & bit) {
        cyclicDependencies.push(name2);
      }
    });
    const cyclicNamesStr = cyclicDependencies.map((n) => `'${n}'`).join(",");
    throw new CompilerError(`Detected a loop dependency: ${cyclicNamesStr}`, node.loc);
  }
}
function isAssignmentExpressionLeft(innerPath) {
  let parentPath = innerPath.parentPath;
  while (parentPath && !parentPath.isStatement()) {
    if (parentPath.isAssignmentExpression()) {
      if (parentPath.node.left === innerPath.node)
        return parentPath;
      const leftPath = parentPath.get("left");
      if (innerPath.isDescendant(leftPath))
        return parentPath;
    } else if (parentPath.isUpdateExpression()) {
      return parentPath;
    }
    parentPath = parentPath.parentPath;
  }
  return null;
}
function isAssignmentFunction(innerPath, reactivityFuncNames2) {
  let parentPath = innerPath.parentPath;
  while (parentPath && parentPath.isMemberExpression()) {
    parentPath = parentPath.parentPath;
  }
  if (!parentPath)
    return false;
  return parentPath.isCallExpression() && parentPath.get("callee").isIdentifier() && reactivityFuncNames2.includes(parentPath.get("callee").node.name);
}
function valueWrapper(node) {
  return types2.file(types2.program([types2.isStatement(node) ? node : types2.expressionStatement(node)]));
}
function geneDependencyNode(path2) {
  let parentPath = path2;
  while (parentPath == null ? void 0 : parentPath.parentPath) {
    const pParentPath = parentPath.parentPath;
    if (!(types2.isMemberExpression(pParentPath.node, { computed: false }) || types2.isOptionalMemberExpression(pParentPath.node))) {
      break;
    }
    parentPath = pParentPath;
  }
  const depNode = types2.cloneNode(parentPath.node);
  getBabelApi().traverse(valueWrapper(depNode), {
    MemberExpression: (innerPath) => {
      if (types2.isThisExpression(innerPath.node.object))
        return;
      innerPath.node.optional = true;
      innerPath.node.type = "OptionalMemberExpression";
    }
  });
  return depNode;
}
function isMemberInUntrackFunction(innerPath) {
  let isInFunction = false;
  let reversePath = innerPath.parentPath;
  while (reversePath) {
    const node = reversePath.node;
    if (types2.isCallExpression(node) && types2.isIdentifier(node.callee) && ["untrack", "$$untrack"].includes(node.callee.name)) {
      isInFunction = true;
      break;
    }
    reversePath = reversePath.parentPath;
  }
  return isInFunction;
}
function isStandAloneIdentifier(path2) {
  const node = path2.node;
  if (isIdentifierProperty(path2))
    return false;
  const isFunctionParam = isAttrFromFunction(path2, node.name);
  if (isFunctionParam)
    return false;
  while (path2.parentPath) {
    if (types2.isVariableDeclarator(path2.parentPath.node))
      return false;
    if (types2.isObjectProperty(path2.parentPath.node) && path2.parentPath.node.key === path2.node && !path2.parentPath.node.computed)
      return false;
    path2 = path2.parentPath;
  }
  return true;
}
function isIdentifierProperty(path2) {
  var _a2;
  const parentNode = (_a2 = path2.parentPath) == null ? void 0 : _a2.node;
  const node = path2.node;
  return types2.isMemberExpression(parentNode) && parentNode.property === node && !parentNode.computed;
}
function isAttrFromFunction(path2, idName) {
  let reversePath = path2.parentPath;
  function checkParam(param) {
    if (types2.isIdentifier(param))
      return param.name === idName;
    if (types2.isAssignmentPattern(param))
      return checkParam(param.left);
    if (types2.isArrayPattern(param)) {
      return param.elements.filter(Boolean).map((el) => checkParam(el)).includes(true);
    }
    if (types2.isObjectPattern(param)) {
      return param.properties.filter((prop) => types2.isObjectProperty(prop) && types2.isIdentifier(prop.key)).map((prop) => prop.key.name).includes(idName);
    }
    if (types2.isRestElement(param))
      return checkParam(param.argument);
    return false;
  }
  while (reversePath) {
    const node = reversePath.node;
    if (types2.isArrowFunctionExpression(node) || types2.isFunctionDeclaration(node)) {
      for (const param of node.params) {
        if (checkParam(param))
          return true;
      }
    }
    reversePath = reversePath.parentPath;
  }
  return false;
}
var _ReactivityParser = class {
  /**
   * @brief Constructor
   * @param config
   */
  constructor(config) {
    __publicField(this, "config");
    __publicField(this, "t");
    __publicField(this, "traverse");
    /**
     * The reactive bit map in the specific scope.
     * We utilize bitmaps to detect concurrent read-write operations on reactive variables
     */
    __publicField(this, "reactiveBitMap");
    __publicField(this, "reactivityFuncNames");
    __publicField(this, "usedReactiveBits", 0);
    var _a2;
    this.config = config;
    this.t = config.babelApi.types;
    this.traverse = config.babelApi.traverse;
    this.reactiveBitMap = config.reactiveMap;
    this.reactivityFuncNames = (_a2 = config.reactivityFuncNames) != null ? _a2 : [];
  }
  addReactiveBits(dependency) {
    this.usedReactiveBits |= dependency.depIdBitmap;
  }
  mergeReactiveBits(other) {
    this.usedReactiveBits |= other.usedReactiveBits;
  }
  /**
   * @brief Parse the ViewUnit into a ViewParticle
   * @returns
   */
  parse(viewUnit) {
    return this.parseViewUnit(viewUnit);
  }
  /**
   * @brief Parse a ViewUnit into a ViewParticle
   * @param viewUnit
   * @returns ViewParticle
   */
  parseViewUnit(viewUnit) {
    if (this.isHTMLTemplate(viewUnit))
      return this.parseTemplate(viewUnit);
    if (viewUnit.type === "text")
      return this.parseText(viewUnit);
    if (viewUnit.type === "html")
      return this.parseHTML(viewUnit);
    if (viewUnit.type === "comp")
      return this.parseComp(viewUnit);
    if (viewUnit.type === "for")
      return this.parseFor(viewUnit);
    if (viewUnit.type === "if")
      return this.parseIf(viewUnit);
    if (viewUnit.type === "context")
      return this.parseContext(viewUnit);
    if (viewUnit.type === "exp")
      return this.parseExp(viewUnit);
    if (viewUnit.type === "fragment")
      return this.parseFragment(viewUnit);
    if (viewUnit.type === "suspense")
      return this.parseSuspense(viewUnit);
    return DLError.throw1();
  }
  // ---- Parsers ----
  // ---- @Template ----
  /**
   * @brief Collect static HTMLUnit into a template particle and generate a template string
   *  MutableParticle means whatever unit that is not a static HTMLUnit or a TextUnit
   *  Props means all the non-static props of the nested HTMLUnit or TextUnit, e.g. div().className(this.name)
   * @param htmlUnit
   * @returns TemplateParticle
   */
  parseTemplate(htmlUnit) {
    return {
      type: "template",
      template: this.generateTemplate(htmlUnit),
      props: this.parseTemplateProps(htmlUnit),
      mutableParticles: this.generateMutableParticles(htmlUnit)
    };
  }
  parseFragment(fragmentUnit) {
    return {
      type: "fragment",
      children: fragmentUnit.children.map(this.parseViewParticle.bind(this))
    };
  }
  /**
   * @brief Generate a template
   *  There'll be a situation where the tag is dynamic, e.g. tag(this.htmlTag),
   *  which we can't generate a template string for it, so we'll wrap it in an ExpParticle in parseHTML() section
   * @returns template string
   * @param unit
   */
  generateTemplate(unit) {
    const staticProps = this.filterTemplateProps(
      // ---- Get all the static props
      Object.entries(unit.props).filter(
        ([, prop]) => this.isStaticProp(prop) && // ---- Filter out props with false values
        !(this.t.isBooleanLiteral(prop.value) && !prop.value.value)
      )
    ).map(([key, prop]) => [
      key,
      __spreadProps(__spreadValues({}, prop), {
        depMask: 0,
        allDepBits: [],
        dependenciesNode: this.t.arrayExpression([])
      })
    ]);
    let children = [];
    if (!unit.props.textContent) {
      children = unit.children.map((unit2) => {
        if (unit2.type === "html" && this.t.isStringLiteral(unit2.tag)) {
          return this.generateTemplate(unit2);
        }
        if (unit2.type === "text" && this.t.isStringLiteral(unit2.content)) {
          return this.parseText(unit2);
        }
      }).filter(Boolean);
    }
    return {
      type: "html",
      tag: unit.tag,
      props: Object.fromEntries(staticProps),
      children
    };
  }
  /**
   * @brief Collect all the mutable nodes in a static HTMLUnit
   *  We use this function to collect mutable nodes' path and props,
   *  so that in the generate, we know which position to insert the mutable nodes
   * @param htmlUnit
   * @returns mutable particles
   */
  generateMutableParticles(htmlUnit) {
    const mutableParticles = [];
    const generateMutableUnit = (unit, path2 = []) => {
      var _a2, _b;
      (_a2 = unit.children) == null ? void 0 : _a2.forEach((child, idx) => {
        if (!(child.type === "html" && this.t.isStringLiteral(child.tag)) && !(child.type === "text" && this.t.isStringLiteral(child.content))) {
          mutableParticles.push(__spreadValues({
            path: [...path2, idx]
          }, this.parseViewParticle(child)));
        }
      });
      (_b = unit.children) == null ? void 0 : _b.filter(
        (child) => child.type === "html" && this.t.isStringLiteral(child.tag) || child.type === "text" && this.t.isStringLiteral(child.content)
      ).forEach((child, idx) => {
        if (child.type === "html") {
          generateMutableUnit(child, [...path2, idx]);
        }
      });
    };
    generateMutableUnit(htmlUnit);
    return mutableParticles;
  }
  /**
   * @brief Collect all the props in a static HTMLUnit or its nested HTMLUnit or TextUnit children
   *  Just like the mutable nodes, props are also equipped with path,
   *  so that we know which HTML ChildNode to insert the props
   * @param htmlUnit
   * @returns props
   */
  parseTemplateProps(htmlUnit) {
    const templateProps = [];
    const generateVariableProp = (unit, path2) => {
      Object.entries(unit.props).filter(([, prop]) => !this.isStaticProp(prop)).forEach(([key, prop]) => {
        templateProps.push(__spreadValues({
          tag: unit.tag.value,
          key,
          path: path2,
          value: prop.value
        }, this.getDependencies(prop.value)));
      });
      unit.children.filter(
        (child) => child.type === "html" && this.t.isStringLiteral(child.tag) || child.type === "text" && this.t.isStringLiteral(child.content)
      ).forEach((child, idx) => {
        if (child.type === "html") {
          generateVariableProp(child, [...path2, idx]);
        } else if (child.type === "text") {
          templateProps.push({
            tag: "text",
            key: "value",
            path: [...path2, idx],
            value: child.content,
            dependenciesNode: this.t.arrayExpression([]),
            depIdBitmap: 0
          });
        }
      });
    };
    generateVariableProp(htmlUnit, []);
    return templateProps;
  }
  // ---- @Text ----
  /**
   * @brief Parse a TextUnit into a TextParticle.
   *  This is only for a top level TextUnit, because if nested in HTMLUnit, it'll be parsed in the template string
   * @param textUnit
   * @returns TextParticle
   */
  parseText(textUnit) {
    return {
      type: "text",
      content: __spreadValues({
        value: textUnit.content
      }, this.getDependencies(textUnit.content))
    };
  }
  // ---- @HTML ----
  /**
   * @brief Parse an HTMLUnit with a dynamic tag into an ExpParticle or an HTMLParticle
   *  We detect dependencies in the tag, if there's no dependency,
   *  we parse it as an HTMLParticle and dynamically append it to the parent node;
   *  if there's dependency, we parse it as an ExpParticle and wrap it in an ExpParticle
   *  so that we can make the tag reactive
   * @param htmlUnit
   * @returns ExpParticle | HTMLParticle
   */
  parseHTML(htmlUnit) {
    const innerHTMLParticle = {
      type: "html",
      tag: htmlUnit.tag,
      props: {},
      children: []
    };
    innerHTMLParticle.props = Object.fromEntries(
      Object.entries(htmlUnit.props).map(([key, prop]) => [key, this.generateDependencyProp(prop)])
    );
    innerHTMLParticle.children = htmlUnit.children.map(this.parseViewParticle.bind(this));
    return innerHTMLParticle;
  }
  // ---- @Comp ----
  /**
   * @brief Parse a CompUnit into a CompParticle or an ExpParticle
   *  Similar to parseHTML(), we detect dependencies in the tag, if there's no dependency,
   *  we parse it as a regular CompParticle, otherwise we wrap it with an ExpParticle.
   * @param compUnit
   * @returns CompParticle | ExpParticle
   */
  parseComp(compUnit) {
    const compParticle = {
      type: "comp",
      tag: compUnit.tag,
      props: {},
      children: []
    };
    compParticle.props = Object.fromEntries(
      Object.entries(compUnit.props).map(([key, prop]) => [key, this.generateDependencyProp(prop)])
    );
    compParticle.children = compUnit.children.map(this.parseViewParticle.bind(this));
    return compParticle;
  }
  // ---- @For ----
  /**
   * @brief Parse a ForUnit into a ForParticle with dependencies
   *  Key and item doesn't need to be reactive, so here we don't collect dependencies for it
   * @param forUnit
   * @returns ForParticle
   */
  parseFor(forUnit) {
    var _a2;
    const { dependenciesNode, depIdBitmap } = this.getDependencies(forUnit.array);
    const prevMap = this.config.reactiveMap;
    const prevDerivedMap = (_a2 = this.config.derivedMap) != null ? _a2 : /* @__PURE__ */ new Map();
    const itemWrapper = this.t.assignmentExpression("=", forUnit.item, this.t.objectExpression([]));
    const arrayReactBits = depIdBitmap;
    this.config.reactiveMap = new Map([
      ...this.config.reactiveMap,
      ...this.getIdentifiers(itemWrapper).map((id) => [id, arrayReactBits])
    ]);
    const forParticle = {
      type: "for",
      item: forUnit.item,
      index: forUnit.index,
      array: {
        value: forUnit.array,
        dependenciesNode,
        depIdBitmap
      },
      children: forUnit.children.map(this.parseViewParticle.bind(this)),
      key: forUnit.key
    };
    this.config.reactiveMap = prevMap;
    this.config.derivedMap = prevDerivedMap;
    return forParticle;
  }
  // ---- @If ----
  /**
   * @brief Parse an IfUnit into an IfParticle with dependencies
   * @param ifUnit
   * @returns IfParticle
   */
  parseIf(ifUnit) {
    return {
      type: "if",
      branches: ifUnit.branches.map((branch) => ({
        condition: __spreadValues({
          value: branch.condition
        }, this.getDependencies(branch.condition)),
        children: branch.children.map(this.parseViewParticle.bind(this))
      }))
    };
  }
  // ---- @Context ----
  /**
   * @brief Parse an ContextUnit into an ContextParticle with dependencies
   * @param contextProviderUnit
   * @returns ContextParticle
   */
  parseContext(contextProviderUnit) {
    return {
      type: "context",
      contextName: contextProviderUnit.contextName,
      props: Object.fromEntries(
        Object.entries(contextProviderUnit.props).map(([key, prop]) => [key, this.generateDependencyProp(prop)])
      ),
      children: contextProviderUnit.children.map(this.parseViewParticle.bind(this))
    };
  }
  parseSuspense(viewUnit) {
    return {
      type: "suspense",
      children: viewUnit.children.map(this.parseViewParticle.bind(this)),
      fallback: viewUnit.fallback
    };
  }
  // ---- @Exp ----
  /**
   * @brief Parse an ExpUnit into an ExpParticle with dependencies
   * @param expUnit
   * @returns ExpParticle
   */
  parseExp(expUnit) {
    return {
      type: "exp",
      content: this.generateDependencyProp(expUnit.content)
    };
  }
  // ---- Dependencies ----
  /**
   * @brief Generate a dependency prop with dependencies
   * @param prop
   * @returns DependencyProp
   */
  generateDependencyProp(prop) {
    return __spreadProps(__spreadValues({
      value: prop.value
    }, this.getDependencies(prop.value)), {
      viewPropMap: Object.fromEntries(
        Object.entries(prop.viewPropMap).map(([key, units]) => [key, units.map(this.parseViewParticle.bind(this))])
      )
    });
  }
  /**
   * Get all the dependencies of a node
   * @param node
   * @returns Dependency | null
   */
  getDependencies(node) {
    const emptyDependency = {
      depIdBitmap: 0,
      dependenciesNode: this.t.arrayExpression([])
    };
    if (this.t.isFunctionExpression(node) || this.t.isArrowFunctionExpression(node)) {
      return emptyDependency;
    }
    const dependency = getDependenciesFromNode(node, this.reactiveBitMap, this.reactivityFuncNames);
    if (dependency) {
      this.addReactiveBits(dependency);
      return dependency;
    }
    return emptyDependency;
  }
  // ---- Utils ----
  /**
   * @brief Parse a ViewUnit into a ViewParticle by new-ing a ReactivityParser
   * @param viewUnit
   * @returns ViewParticle
   */
  parseViewParticle(viewUnit) {
    const parser = new _ReactivityParser(this.config);
    const parsedUnit = parser.parse(viewUnit);
    this.mergeReactiveBits(parser);
    return parsedUnit;
  }
  /**
   * @brief Check if a ViewUnit is a static HTMLUnit that can be parsed into a template
   *  Must satisfy:
   *  1. type is html
   *  2. tag is a string literal, i.e., non-dynamic tag
   *  3. has at least one child that is a static HTMLUnit,
   *     or else just call a createElement function, no need for template clone
   * @param viewUnit
   * @returns is a static HTMLUnit
   */
  isHTMLTemplate(viewUnit) {
    var _a2;
    return viewUnit.type === "html" && this.t.isStringLiteral(viewUnit.tag) && !!((_a2 = viewUnit.children) == null ? void 0 : _a2.some((child) => child.type === "html" && this.t.isStringLiteral(child.tag)));
  }
  /**
   * @brief Check if a prop is a static prop
   *  i.e.
   *  1. no viewPropMap
   *  2. value is a string/number/boolean literal
   * @param prop
   * @returns is a static prop
   */
  isStaticProp(prop) {
    const { value, viewPropMap } = prop;
    return (!viewPropMap || Object.keys(viewPropMap).length === 0) && (this.t.isStringLiteral(value) || this.t.isNumericLiteral(value) || this.t.isBooleanLiteral(value));
  }
  /**
   * @brief Filter out some props that are not needed in the template,
   *  these are all special props to be parsed differently in the generate
   * @param props
   * @returns filtered props
   */
  filterTemplateProps(props) {
    return props.filter(([key]) => !key.startsWith("on")).filter(([key]) => !_ReactivityParser.customHTMLProps.includes(key));
  }
  /**
   * @brief Wrap the value in a file
   * @param node
   * @returns wrapped value
   */
  valueWrapper(node) {
    return this.t.file(this.t.program([this.t.isStatement(node) ? node : this.t.expressionStatement(node)]));
  }
  /**
   * @brief Check if an identifier is a simple stand alone identifier,
   *  i.e., not a member expression, nor a function param
   * @param path
   *  1. not a member expression
   *  2. not a function param
   *  3. not in a declaration
   *  4. not as object property's not computed key
   * @returns is a stand alone identifier
   */
  isStandAloneIdentifier(path2) {
    var _a2;
    const node = path2.node;
    const parentNode = (_a2 = path2.parentPath) == null ? void 0 : _a2.node;
    const isMemberExpression = this.t.isMemberExpression(parentNode) && parentNode.property === node;
    if (isMemberExpression)
      return false;
    const isFunctionParam = this.isAttrFromFunction(path2, node.name);
    if (isFunctionParam)
      return false;
    while (path2.parentPath) {
      if (this.t.isVariableDeclarator(path2.parentPath.node))
        return false;
      if (this.t.isObjectProperty(path2.parentPath.node) && path2.parentPath.node.key === path2.node && !path2.parentPath.node.computed)
        return false;
      path2 = path2.parentPath;
    }
    return true;
  }
  /**
   * @brief Get all identifiers as strings in a node
   * @param node
   * @returns identifiers
   */
  getIdentifiers(node) {
    if (this.t.isIdentifier(node))
      return [node.name];
    const identifierKeys = /* @__PURE__ */ new Set();
    this.traverse(this.valueWrapper(node), {
      Identifier: (innerPath) => {
        if (!this.isStandAloneIdentifier(innerPath))
          return;
        identifierKeys.add(innerPath.node.name);
      }
    });
    return [...identifierKeys];
  }
  /**
   * @brief check if the identifier is from a function param till the stopNode
   *  e.g:
   *  function myFunc1(ok) { // stopNode = functionBody
   *     const myFunc2 = ok => ok // from function param
   *     console.log(ok) // not from function param
   *  }
   */
  isAttrFromFunction(path2, idName) {
    let reversePath = path2.parentPath;
    const checkParam = (param) => {
      if (this.t.isIdentifier(param))
        return param.name === idName;
      if (this.t.isAssignmentPattern(param))
        return checkParam(param.left);
      if (this.t.isArrayPattern(param)) {
        return param.elements.filter(Boolean).map((el) => checkParam(el)).includes(true);
      }
      if (this.t.isObjectPattern(param)) {
        return param.properties.filter(
          (prop) => this.t.isObjectProperty(prop) && this.t.isIdentifier(prop.key)
        ).map((prop) => prop.key.name).includes(idName);
      }
      if (this.t.isRestElement(param))
        return checkParam(param.argument);
      return false;
    };
    while (reversePath) {
      const node = reversePath.node;
      if (this.t.isArrowFunctionExpression(node) || this.t.isFunctionDeclaration(node)) {
        for (const param of node.params) {
          if (checkParam(param))
            return true;
        }
      }
      reversePath = reversePath.parentPath;
    }
    return false;
  }
};
var ReactivityParser = _ReactivityParser;
__publicField2(ReactivityParser, "customHTMLProps", [
  "didUpdate",
  "willMount",
  "didMount",
  "willUnmount",
  "didUnmount",
  "element",
  "innerHTML",
  "props",
  "attrs",
  "dataset",
  "forwardProps"
]);
function parseReactivity(viewUnit, config) {
  const parser = new ReactivityParser(config);
  const particle = parser.parse(viewUnit);
  return [particle, parser.usedReactiveBits];
}

// ../jsx-parser/dist/index.js
function cleanJSXText(node) {
  const textLines = node.value.split(/\r\n|\n|\r/);
  let indexOfLastNonEmptyLine = textLines.length - 1;
  for (let i = 0; i < textLines.length; i++) {
    if (/[^ \t]/.test(textLines[i])) {
      indexOfLastNonEmptyLine = i;
      break;
    }
  }
  return textLines.reduce((cleanedText, currentLine, currentIndex) => {
    let processedLine = currentLine.replace(/\t/g, " ");
    if (currentIndex !== 0) {
      processedLine = processedLine.replace(/^[ ]+/, "");
    }
    if (currentIndex !== textLines.length - 1) {
      processedLine = processedLine.replace(/[ ]+$/, "");
    }
    if (processedLine) {
      cleanedText += processedLine;
      if (currentIndex !== indexOfLastNonEmptyLine) {
        cleanedText += " ";
      }
    }
    return cleanedText;
  }, "");
}
var CompilerError2 = class extends Error {
  constructor(message, loc, suggestion) {
    super(message);
    this.message = message;
    this.loc = loc;
    this.suggestion = suggestion;
  }
  static invariant(condition, message, loc, suggestion) {
    if (!condition) {
      throw new CompilerError2(message, loc, suggestion);
    }
  }
};
function isContext(str) {
  return /^[A-Z][a-zA-Z0-9]*Context/.test(str);
}
function isSuspense(str) {
  return str === "Suspense";
}
var ViewParser = class {
  /**
   * @brief Constructor
   * @param config
   * @param context
   */
  constructor(config, context = { ifElseStack: [] }) {
    // ---- Namespace and tag name
    __publicField(this, "htmlNamespace", "html");
    __publicField(this, "htmlTagNamespace", "tag");
    __publicField(this, "compTagNamespace", "comp");
    __publicField(this, "envTagName", "env");
    __publicField(this, "forTagName", "for");
    __publicField(this, "ifTagName", "if");
    __publicField(this, "elseIfTagName", "else-if");
    __publicField(this, "elseTagName", "else");
    __publicField(this, "customHTMLProps", ["ref"]);
    __publicField(this, "config");
    __publicField(this, "htmlTags");
    __publicField(this, "willParseTemplate");
    __publicField(this, "t");
    __publicField(this, "traverse");
    __publicField(this, "viewUnits", []);
    __publicField(this, "context");
    var _a2;
    this.config = config;
    this.t = config.babelApi.types;
    this.traverse = config.babelApi.traverse;
    this.htmlTags = config.htmlTags;
    this.willParseTemplate = (_a2 = config.parseTemplate) != null ? _a2 : true;
    this.context = context;
  }
  /**
   * @brief Parse the node into view units
   * @param node
   * @returns ViewUnit[]
   */
  parse(node) {
    if (this.t.isJSXText(node))
      this.parseText(node);
    else if (this.t.isJSXExpressionContainer(node))
      this.parseExpression(node.expression);
    else if (this.t.isJSXElement(node))
      this.parseElement(node);
    else if (this.t.isJSXFragment(node)) {
      this.parseFragment(node);
    }
    return this.viewUnits;
  }
  parseFragment(node) {
    this.viewUnits.push({
      type: "fragment",
      children: node.children.map((child) => this.parseView(child)).flat()
    });
  }
  /**
   * @brief Parse JSXText
   * @param node
   */
  parseText(node) {
    const text = cleanJSXText(node);
    if (!text)
      return;
    this.viewUnits.push({
      type: "text",
      content: this.t.stringLiteral(text)
    });
  }
  /**
   * @brief Parse JSXExpressionContainer
   * @param node
   */
  parseExpression(node) {
    if (this.t.isJSXEmptyExpression(node))
      return;
    if (this.t.isLiteral(node) && !this.t.isTemplateLiteral(node)) {
      this.viewUnits.push({
        type: "text",
        content: node
      });
      return;
    }
    this.viewUnits.push({
      type: "exp",
      content: this.parseProp(node),
      props: {}
    });
  }
  /**
   * @brief Parse JSXElement
   * @param node
   */
  parseElement(node) {
    let type;
    let tag;
    const openingName = node.openingElement.name;
    if (this.t.isJSXIdentifier(openingName)) {
      const name2 = openingName.name;
      if ([this.ifTagName, this.elseIfTagName, this.elseTagName].includes(name2))
        return this.parseIf(node);
      if (isContext(name2))
        return this.parseContext(node, name2);
      if (isSuspense(name2))
        return this.parseSuspense(node, name2);
      if (name2 === this.forTagName)
        return this.parseFor(node);
      else if (this.htmlTags.includes(name2)) {
        type = "html";
        tag = this.t.stringLiteral(name2);
      } else {
        type = "comp";
        tag = this.t.identifier(name2);
      }
    } else if (this.t.isJSXMemberExpression(openingName)) {
      type = "comp";
      const toMemberExpression = (node2) => {
        if (this.t.isJSXMemberExpression(node2.object)) {
          return this.t.memberExpression(toMemberExpression(node2.object), this.t.identifier(node2.property.name));
        }
        return this.t.memberExpression(this.t.identifier(node2.object.name), this.t.identifier(node2.property.name));
      };
      tag = toMemberExpression(openingName);
    } else {
      const namespace = openingName.namespace.name;
      switch (namespace) {
        case this.compTagNamespace:
          type = "comp";
          tag = this.t.identifier(openingName.name.name);
          break;
        case this.htmlNamespace:
          type = "html";
          tag = this.t.stringLiteral(openingName.name.name);
          break;
        case this.htmlTagNamespace:
          type = "html";
          tag = this.t.identifier(openingName.name.name);
          break;
        default:
          type = "html";
          tag = this.t.stringLiteral(`${namespace}:${openingName.name.name}`);
          break;
      }
    }
    const props = node.openingElement.attributes;
    const propMap = Object.fromEntries(props.map((prop) => this.parseJSXProp(prop)));
    const childUnits = node.children.map((child) => this.parseView(child)).flat();
    let unit = { type, tag, props: propMap, children: childUnits };
    if (unit.type === "html" && childUnits.length === 1 && childUnits[0].type === "text") {
      const text = childUnits[0];
      unit = __spreadProps(__spreadValues({}, unit), {
        children: [],
        props: __spreadProps(__spreadValues({}, unit.props), {
          textContent: {
            value: text.content,
            viewPropMap: {}
          }
        })
      });
    }
    if (unit.type === "html")
      unit = this.transformTemplate(unit);
    this.viewUnits.push(unit);
  }
  /**
   * @brief Parse ContextProvider
   * @param node
   * @param contextName
   */
  parseContext(node, contextName) {
    const props = node.openingElement.attributes;
    const propMap = Object.fromEntries(props.map((prop) => this.parseJSXProp(prop)));
    const children = node.children.map((child) => this.parseView(child)).flat();
    this.viewUnits.push({
      type: "context",
      props: propMap,
      contextName,
      children
    });
  }
  parseSuspense(node, name2) {
    const children = node.children.map((child) => this.parseView(child)).flat();
    const props = node.openingElement.attributes;
    const fallbackProp = props.find(
      (prop) => this.t.isJSXAttribute(prop) && prop.name.name === "fallback"
    );
    const fallback = fallbackProp ? this.parseJSXProp(fallbackProp)[1] : null;
    this.viewUnits.push({
      type: "suspense",
      children,
      fallback
    });
  }
  parseIf(node) {
    const name2 = node.openingElement.name.name;
    if (name2 === this.elseTagName) {
      const lastUnit2 = this.context.ifElseStack[this.context.ifElseStack.length - 1];
      if (!lastUnit2 || lastUnit2.type !== "if")
        throw new CompilerError2(`Missing if for ${name2}`, node.loc);
      lastUnit2.branches.push({
        condition: this.t.booleanLiteral(true),
        children: node.children.map((child) => this.parseView(child)).flat()
      });
      this.context.ifElseStack.pop();
      return;
    }
    const condition = node.openingElement.attributes.filter(
      (attr) => this.t.isJSXAttribute(attr) && attr.name.name === "cond"
    )[0];
    CompilerError2.invariant(!!condition, `Missing condition for ${name2}`, node.openingElement.loc);
    CompilerError2.invariant(
      this.t.isJSXAttribute(condition),
      `JSXSpreadAttribute is not supported for ${name2} condition`,
      condition.loc
    );
    CompilerError2.invariant(
      this.t.isJSXExpressionContainer(condition.value) && this.t.isExpression(condition.value.expression),
      `Invalid condition for ${name2}, condition must be a JSXExpressionContainer`,
      condition.loc
    );
    if (name2 === this.ifTagName) {
      const unit = {
        type: "if",
        branches: [
          {
            condition: condition.value.expression,
            children: node.children.map((child) => this.parseView(child)).flat()
          }
        ]
      };
      this.viewUnits.push(unit);
      this.context.ifElseStack.push(unit);
      return;
    }
    const lastUnit = this.context.ifElseStack[this.context.ifElseStack.length - 1];
    CompilerError2.invariant(lastUnit && lastUnit.type === "if", `Missing if for ${name2}`, node.loc);
    lastUnit.branches.push({
      condition: condition.value.expression,
      children: node.children.map((child) => this.parseView(child)).flat()
    });
  }
  /**
   * @brief Parse JSXAttribute or JSXSpreadAttribute into UnitProp,
   *  considering both namespace and expression
   * @param prop
   * @returns [propName, propValue]
   */
  parseJSXProp(prop) {
    if (this.t.isJSXAttribute(prop)) {
      let propName, specifier;
      if (this.t.isJSXNamespacedName(prop.name)) {
        propName = prop.name.name.name;
        specifier = prop.name.namespace.name;
      } else {
        propName = prop.name.name;
      }
      let value = this.t.isJSXExpressionContainer(prop.value) ? prop.value.expression : prop.value;
      if (this.t.isJSXEmptyExpression(value))
        value = void 0;
      return [propName, this.parseProp(value, specifier)];
    }
    return ["*spread*", this.parseProp(prop.argument)];
  }
  /**
   * @brief Parse the prop node into UnitProp
   * @param propNode
   * @param specifier
   * @returns UnitProp
   */
  parseProp(propNode, specifier) {
    if (!propNode) {
      return {
        value: this.t.booleanLiteral(true),
        viewPropMap: {}
      };
    }
    const viewPropMap = {};
    const parseViewProp = (innerPath) => {
      const id = this.uid();
      const node = innerPath.node;
      viewPropMap[id] = this.parseView(node);
      const newNode = this.t.stringLiteral(id);
      if (node === propNode) {
        propNode = newNode;
      }
      innerPath.replaceWith(newNode);
      innerPath.skip();
    };
    this.traverse(this.wrapWithFile(propNode), {
      JSXElement: parseViewProp,
      JSXFragment: parseViewProp
    });
    return {
      value: propNode,
      viewPropMap,
      specifier
    };
  }
  transformTemplate(unit) {
    if (!this.willParseTemplate)
      return unit;
    if (!this.isHTMLTemplate(unit))
      return unit;
    unit = unit;
    return {
      type: "template",
      template: this.generateTemplate(unit),
      mutableUnits: this.generateMutableUnits(unit),
      props: this.parseTemplateProps(unit)
    };
  }
  /**
   * @brief Generate the entire HTMLUnit
   * @param unit
   * @returns HTMLUnit
   */
  generateTemplate(unit) {
    var _a2;
    const staticProps = Object.fromEntries(
      this.filterTemplateProps(
        // ---- Get all the static props
        Object.entries((_a2 = unit.props) != null ? _a2 : []).filter(
          ([, prop]) => this.isStaticProp(prop) && // ---- Filter out props with false values
          !(this.t.isBooleanLiteral(prop.value) && !prop.value.value)
        )
      )
    );
    let children = [];
    if (unit.children) {
      children = unit.children.map((unit2) => {
        if (unit2.type === "text")
          return unit2;
        if (unit2.type === "html" && this.t.isStringLiteral(unit2.tag)) {
          return this.generateTemplate(unit2);
        }
      }).filter(Boolean);
    }
    return {
      type: "html",
      tag: unit.tag,
      props: staticProps,
      children
    };
  }
  /**
   * @brief Collect all the mutable nodes in a static HTMLUnit
   *  We use this function to collect mutable nodes' path and props,
   *  so that in the generate, we know which position to insert the mutable nodes
   * @param htmlUnit
   * @returns mutable particles
   */
  generateMutableUnits(htmlUnit) {
    const mutableUnits = [];
    const generateMutableUnit = (unit, path2 = []) => {
      var _a2, _b, _c;
      const maxHtmlIdx = (_a2 = unit.children) == null ? void 0 : _a2.filter(
        (child) => child.type === "html" && this.t.isStringLiteral(child.tag) || child.type === "text"
      ).length;
      let htmlIdx = -1;
      (_b = unit.children) == null ? void 0 : _b.forEach((child) => {
        if (!(child.type === "html" && this.t.isStringLiteral(child.tag)) && !(child.type === "text")) {
          const idx = htmlIdx + 1 >= maxHtmlIdx ? -1 : htmlIdx + 1;
          mutableUnits.push(__spreadValues({
            path: [...path2, idx]
          }, this.transformTemplate(child)));
        } else {
          htmlIdx++;
        }
      });
      (_c = unit.children) == null ? void 0 : _c.filter((child) => child.type === "html" && this.t.isStringLiteral(child.tag)).forEach((child, idx) => {
        generateMutableUnit(child, [...path2, idx]);
      });
    };
    generateMutableUnit(htmlUnit);
    return mutableUnits;
  }
  /**
   * @brief Collect all the props in a static HTMLUnit or its nested HTMLUnit children
   *  Just like the mutable nodes, props are also equipped with path,
   *  so that we know which HTML ChildNode to insert the props
   * @param htmlUnit
   * @returns props
   */
  parseTemplateProps(htmlUnit) {
    const templateProps = [];
    const generateVariableProp = (unit, path2) => {
      var _a2;
      unit.props && Object.entries(unit.props).filter(([, prop]) => !this.isStaticProp(prop)).forEach(([key, prop]) => {
        templateProps.push({
          tag: unit.tag,
          name: unit.tag.value,
          key,
          path: path2,
          value: prop.value
        });
      });
      (_a2 = unit.children) == null ? void 0 : _a2.filter((child) => child.type === "html" && this.t.isStringLiteral(child.tag)).forEach((child, idx) => {
        generateVariableProp(child, [...path2, idx]);
      });
    };
    generateVariableProp(htmlUnit, []);
    return templateProps;
  }
  /**
   * @brief Check if a ViewUnit is a static HTMLUnit that can be parsed into a template
   *  Must satisfy:
   *  1. type is html
   *  2. tag is a string literal, i.e., non-dynamic tag
   *  3. has at least one child that is a static HTMLUnit,
   *     or else just call a createElement function, no need for template clone
   * @param viewUnit
   * @returns is a static HTMLUnit
   */
  isHTMLTemplate(viewUnit) {
    var _a2;
    return viewUnit.type === "html" && this.t.isStringLiteral(viewUnit.tag) && !!((_a2 = viewUnit.children) == null ? void 0 : _a2.some((child) => child.type === "html" && this.t.isStringLiteral(child.tag)));
  }
  isStaticProp(prop) {
    return this.t.isStringLiteral(prop.value) || this.t.isNumericLiteral(prop.value) || this.t.isBooleanLiteral(prop.value) || this.t.isNullLiteral(prop.value);
  }
  /**
   * @brief Filter out some props that are not needed in the template,
   *  these are all special props to be parsed differently in the generate
   * @param props
   * @returns filtered props
   */
  filterTemplateProps(props) {
    return props.filter(([key]) => !key.startsWith("on")).filter(([key]) => !this.customHTMLProps.includes(key));
  }
  /**
   * @brief Parse the view by duplicating current parser's classRootPath, statements and htmlTags
   * @param statements
   * @returns ViewUnit[]
   */
  parseView(node) {
    return new ViewParser(__spreadProps(__spreadValues({}, this.config), { parseTemplate: false }), this.context).parse(node);
  }
  /**
   * @brief Wrap the value in a file
   * @param node
   * @returns wrapped value
   */
  wrapWithFile(node) {
    return this.t.file(this.t.program([this.t.expressionStatement(node)]));
  }
  /**
   * @brief Generate a unique id
   * @returns a unique id
   */
  uid() {
    return Math.random().toString(36).slice(2);
  }
  findProp(node, name2) {
    const props = node.openingElement.attributes;
    return props.find((prop) => this.t.isJSXAttribute(prop) && prop.name.name === name2);
  }
  parseFor(node) {
    const arrayContainer = this.findProp(node, "each");
    CompilerError2.invariant(!!arrayContainer, "Missing [each] prop in for loop", node.openingElement.loc);
    CompilerError2.invariant(
      this.t.isJSXExpressionContainer(arrayContainer.value),
      "Expected expression container for [array] prop",
      arrayContainer.loc
    );
    const array = arrayContainer.value.expression;
    CompilerError2.invariant(!this.t.isJSXEmptyExpression(array), "Expected [array] expression not empty", array.loc);
    const keyProp = this.findProp(node, "key");
    let key = null;
    if (keyProp) {
      CompilerError2.invariant(
        this.t.isJSXExpressionContainer(keyProp.value),
        "Expected expression container for [key] prop",
        keyProp.loc
      );
      CompilerError2.invariant(
        !this.t.isJSXEmptyExpression(keyProp.value.expression),
        "Expected [key] expression not empty",
        keyProp.loc
      );
      key = keyProp.value.expression;
    }
    const jsxChildren = node.children.find((child) => this.t.isJSXExpressionContainer(child));
    if (!jsxChildren)
      throw new CompilerError2("Expected expression container", node.loc);
    const itemFnNode = jsxChildren.expression;
    if (this.t.isJSXEmptyExpression(itemFnNode))
      throw new CompilerError2("Expected expression not empty", itemFnNode.loc);
    let children;
    if (!this.t.isFunctionExpression(itemFnNode) && !this.t.isArrowFunctionExpression(itemFnNode)) {
      throw new CompilerError2("For: Expected function expression", itemFnNode.loc);
    }
    if (this.t.isBlockStatement(itemFnNode.body)) {
      if (itemFnNode.body.body.length !== 1)
        throw new CompilerError2("For: Expected 1 statement in block statement", node.loc);
      if (!this.t.isReturnStatement(itemFnNode.body.body[0]))
        throw new CompilerError2("For: Expected return statement in block statement", node.loc);
      children = itemFnNode.body.body[0].argument;
    } else {
      children = itemFnNode.body;
    }
    if (this.t.isJSXElement(children)) {
      const keyAttr = children.openingElement.attributes.find(
        (attr) => this.t.isJSXAttribute(attr) && attr.name.name === "key"
      );
      if ((keyAttr == null ? void 0 : keyAttr.value) && this.t.isJSXExpressionContainer(keyAttr.value) && !this.t.isJSXEmptyExpression(keyAttr.value.expression)) {
        key = keyAttr.value.expression;
      }
    }
    const item = itemFnNode.params[0];
    const index = itemFnNode.params[1] || null;
    if (index && !this.t.isIdentifier(index))
      throw new CompilerError2("For: Expected identifier in function second parameter as index", index.loc);
    if (!this.t.isJSXElement(children))
      throw new CompilerError2("For: Expected jsx element in return statement", (children != null ? children : node).loc);
    this.viewUnits.push({
      type: "for",
      key,
      item,
      index,
      array,
      children: this.parseView(children)
    });
  }
};
function parseView(node, config) {
  return new ViewParser(config).parse(node)[0];
}

// ../view-generator/dist/index.js
var prefixMap = { template: "$t", node: "$node" };
var elementAttributeMap = {};
var alterAttributeMap = {};
var importMap = {};
var nodeNameInUpdate = "$$node";
function runWithConfig(config, fn) {
  elementAttributeMap = config.attributeMap ? Object.entries(config.attributeMap).reduce((acc, [key, elements]) => {
    elements.forEach((element) => {
      if (!acc[element])
        acc[element] = [];
      acc[element].push(key);
    });
    return acc;
  }, {}) : {};
  alterAttributeMap = config.alterAttributeMap;
  importMap = config.importMap;
  const result = fn();
  elementAttributeMap = {};
  alterAttributeMap = {};
  importMap = {};
  return result;
}
var DLError2 = createErrorHandler(
  "ViewGenerator",
  {
    1: "Element prop in HTML should be a function or an identifier",
    2: "Unrecognized HTML common prop",
    3: "Do prop only accepts function or arrow function"
  },
  {},
  {
    1: "ExpressionNode only supports prop as element and lifecycle, receiving $0"
  }
);
var DelegatedEvents = /* @__PURE__ */ new Set([
  "beforeinput",
  "click",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
]);
var commonHTMLPropKeys = ["ref", "style", "dataset", "*spread*"];
function wrapStmt(nodeName, expression) {
  return types2.expressionStatement(expression);
}
function setHTMLStyle(nodeName, value, dependenciesNode, reactBits) {
  const args = reactBits ? [types2.identifier(nodeName), types2.arrowFunctionExpression([], value), dependenciesNode, types2.numericLiteral(reactBits)] : [types2.identifier(nodeName), value];
  return wrapStmt(nodeName, types2.callExpression(types2.identifier(importMap.setStyle), args));
}
function setHTMLDataset(nodeName, value, dependenciesNode, reactBits) {
  const args = reactBits ? [types2.identifier(nodeName), types2.arrowFunctionExpression([], value), dependenciesNode, types2.numericLiteral(reactBits)] : [types2.identifier(nodeName), value];
  return wrapStmt(nodeName, types2.callExpression(types2.identifier("setDataset"), args));
}
function setHTMLAttr(nodeName, key, value, dependenciesNode, reactBits) {
  const args = reactBits ? [types2.stringLiteral(key), types2.arrowFunctionExpression([], value), dependenciesNode, types2.numericLiteral(reactBits)] : [types2.stringLiteral(key), value];
  return types2.expressionStatement(
    types2.callExpression(types2.memberExpression(types2.identifier(nodeName), types2.identifier("setAttribute")), args)
  );
}
function setHTMLProperty(nodeName, key, value) {
  return types2.expressionStatement(
    types2.assignmentExpression("=", types2.memberExpression(types2.identifier(nodeName), types2.identifier(key)), value)
  );
}
function setEvent(nodeName, key, value) {
  return wrapStmt(
    nodeName,
    types2.callExpression(types2.identifier(importMap.setEvent), [types2.identifier(nodeName), types2.stringLiteral(key), value])
  );
}
function delegateEvent(nodeName, key, value, dependenciesNode, reactBits) {
  const args = reactBits ? [
    types2.identifier(nodeName),
    types2.stringLiteral(key),
    types2.arrowFunctionExpression([], value),
    dependenciesNode,
    types2.numericLiteral(reactBits)
  ] : [types2.identifier(nodeName), types2.stringLiteral(key), value];
  return wrapStmt(nodeName, types2.callExpression(types2.identifier(importMap["delegateEvent"]), args));
}
function setCachedProp(nodeName, key, value, dependenciesNode, reactBits) {
  return wrapStmt(
    nodeName,
    types2.callExpression(types2.identifier(importMap.setHTMLProp), [
      types2.identifier(nodeName),
      types2.stringLiteral(key),
      types2.arrowFunctionExpression([], value),
      dependenciesNode,
      types2.numericLiteral(reactBits)
    ])
  );
}
function setCachedAttr(nodeName, key, value, dependenciesNode, reactBits) {
  return wrapStmt(
    nodeName,
    types2.callExpression(types2.identifier(importMap.setHTMLAttr), [
      types2.identifier(nodeName),
      types2.stringLiteral(key),
      types2.arrowFunctionExpression([], value),
      dependenciesNode,
      types2.numericLiteral(reactBits)
    ])
  );
}
function setDynamicHTMLProp(nodeName, tag, attrName, value, dependenciesNode, reactBits) {
  if (commonHTMLPropKeys.includes(attrName))
    return addCommonHTMLProp(nodeName, attrName, value, dependenciesNode, reactBits);
  if (attrName.startsWith("on")) {
    const eventName = attrName.slice(2).toLowerCase();
    if (DelegatedEvents.has(eventName)) {
      return delegateEvent(nodeName, eventName, value, dependenciesNode, reactBits);
    }
    return setEvent(nodeName, eventName, value);
  }
  if (alterAttributeMap[attrName]) {
    attrName = alterAttributeMap[attrName];
  }
  if (isInternalAttribute(tag, attrName)) {
    return setCachedProp(nodeName, attrName, value, dependenciesNode, reactBits);
  }
  return setCachedAttr(nodeName, attrName, value, dependenciesNode, reactBits);
}
function setRef(nodeName, value) {
  const elNode = types2.identifier(nodeName);
  const elementNode = types2.conditionalExpression(
    types2.binaryExpression("===", types2.unaryExpression("typeof", value, true), types2.stringLiteral("function")),
    types2.callExpression(value, [elNode]),
    types2.assignmentExpression("=", value, elNode)
  );
  return types2.expressionStatement(
    types2.callExpression(types2.identifier(importMap.setRef), [elNode, types2.arrowFunctionExpression([], elementNode)])
  );
}
function addCommonHTMLProp(nodeName, attrName, value, dependenciesNode, reactBits) {
  if (attrName === "ref") {
    return setRef(nodeName, value);
  }
  if (attrName === "style")
    return setHTMLStyle(nodeName, value, dependenciesNode, reactBits);
  if (attrName === "dataset")
    return setHTMLDataset(nodeName, value, dependenciesNode, reactBits);
  if (attrName === "props")
    return setHTMLPropObject(nodeName, value);
  if (attrName === "*spread*")
    return setHTMLSpread(nodeName, value, dependenciesNode, reactBits);
  return DLError2.throw2();
}
function setHTMLSpread(nodeName, value, dependenciesNode, reactBits) {
  const args = reactBits ? [types2.identifier(nodeName), types2.arrowFunctionExpression([], value), dependenciesNode, types2.numericLiteral(reactBits)] : [types2.identifier(nodeName), value];
  return types2.expressionStatement(types2.callExpression(types2.identifier(importMap.setHTMLAttrs), args));
}
function isInternalAttribute(tag, attribute) {
  var _a2, _b;
  return ((_a2 = elementAttributeMap["*"]) == null ? void 0 : _a2.includes(attribute)) || ((_b = elementAttributeMap[tag]) == null ? void 0 : _b.includes(attribute));
}
function setStaticHTMLProp(nodeName, tag, attrName, value) {
  if (commonHTMLPropKeys.includes(attrName)) {
    return addCommonHTMLProp(nodeName, attrName, value);
  }
  if (attrName.startsWith("on")) {
    const eventName = attrName.slice(2).toLowerCase();
    if (DelegatedEvents.has(eventName)) {
      return delegateEvent(nodeName, eventName, value);
    }
    return setEvent(nodeName, eventName, value);
  }
  if (isInternalAttribute(tag, attrName)) {
    if (attrName === "class")
      attrName = "className";
    else if (attrName === "for")
      attrName = "htmlFor";
    return setHTMLProperty(nodeName, attrName, value);
  }
  return setHTMLAttr(nodeName, attrName, value);
}
function setHTMLPropObject(nodeName, value) {
  return wrapStmt(nodeName, types2.callExpression(types2.identifier(importMap["setHTMLProps"]), [types2.identifier(nodeName), value]));
}
function setHTMLProp(name2, tag, key, value, reactBits, dependenciesNode) {
  if (reactBits && key !== "ref") {
    return setDynamicHTMLProp(name2, tag, key, value, dependenciesNode != null ? dependenciesNode : types2.arrayExpression([]), reactBits);
  }
  return setStaticHTMLProp(name2, tag, key, value);
}
var htmlGenerator = {
  html: (viewParticle, ctx) => {
    const { getReactBits, importMap: importMap22 } = ctx;
    const { tag, props, children } = viewParticle;
    const propStmts = [];
    const tagName = types2.isStringLiteral(tag) ? tag.value : "ANY";
    Object.entries(props).forEach(([key, { value, depIdBitmap, dependenciesNode }]) => {
      const reactBits = getReactBits(depIdBitmap);
      ctx.wrapUpdate(value);
      const propStmt = setHTMLProp(nodeNameInUpdate, tagName, key, value, reactBits, dependenciesNode);
      if (propStmt) {
        propStmts.push(propStmt);
      }
    });
    const propsUpdater = propStmts.length > 0 ? types2.arrowFunctionExpression([types2.identifier(nodeNameInUpdate)], types2.blockStatement(propStmts)) : types2.nullLiteral();
    const childrenNodes = children.map((child) => ctx.next(child));
    return types2.callExpression(types2.identifier(importMap22.createHTMLNode), [
      types2.stringLiteral(tagName),
      propsUpdater,
      ...childrenNodes
    ]);
  }
};
var PARAM_NODE = "$$n";
var PARAM_INDEX = "$$i";
var PARAM_KEY = "$$key";
var forGenerator = {
  for: ({ item, index: indexParam, array, key, children }, ctx) => {
    if (!types2.isIdentifier(item) && !types2.isObjectPattern(item) && !types2.isArrayPattern(item)) {
      throw new Error("ForGenerator: item cannot be a member expression");
    }
    const index = indexParam != null ? indexParam : types2.identifier(PARAM_INDEX);
    const updateItemFuncArr = types2.identifier("updateItemFuncArr");
    return types2.callExpression(types2.identifier(importMap.createForNode), [
      // Array
      types2.arrowFunctionExpression([], array.value),
      // Key
      keyMappingFn(array, item, indexParam, key),
      // Update func
      types2.arrowFunctionExpression(
        [types2.identifier(PARAM_NODE), updateItemFuncArr, item, types2.identifier(PARAM_KEY), index],
        types2.blockStatement([
          types2.expressionStatement(
            types2.assignmentExpression(
              "=",
              types2.memberExpression(updateItemFuncArr, index, true),
              itemUpdater(item, indexParam)
            )
          ),
          types2.returnStatement(types2.arrayExpression(children.map((child) => ctx.next(child))))
        ])
      ),
      // reactBits
      types2.numericLiteral(ctx.getReactBits(array.depIdBitmap))
    ]);
  }
};
function keyMappingFn(array, item, index, key) {
  if (!key) {
    return types2.nullLiteral();
  }
  const params = [item];
  if (index) {
    params.push(index);
  }
  return types2.arrowFunctionExpression(
    [],
    types2.callExpression(types2.memberExpression(array.value, types2.identifier("map")), [types2.arrowFunctionExpression(params, key)])
  );
}
function itemUpdater(item, indexParam) {
  const newItem = types2.identifier("newItem");
  const newIdx = types2.identifier("newIdx");
  const itemAssign = types2.expressionStatement(types2.assignmentExpression("=", item, newItem));
  const indexAssign = indexParam && types2.expressionStatement(types2.assignmentExpression("=", indexParam, newIdx));
  return types2.arrowFunctionExpression(
    [newItem, newIdx],
    types2.blockStatement([itemAssign, indexAssign].filter((s) => Boolean(s)))
  );
}
function generateNodeName(ctx, idx) {
  return `${prefixMap.node}${idx != null ? idx : ctx.nodeIdx++}`;
}
function appendChild(nodeName, childNodeName) {
  return types2.expressionStatement(
    types2.callExpression(types2.memberExpression(types2.identifier(nodeName), types2.identifier("appendChild")), [
      types2.identifier(childNodeName)
    ])
  );
}
function declareHTMLNode(dlNodeName, tag) {
  return types2.variableDeclaration("const", [
    types2.variableDeclarator(types2.identifier(dlNodeName), types2.callExpression(types2.identifier(importMap.createElement), [tag]))
  ]);
}
var genTemplateContent = (template) => {
  const statements = [];
  const visit = (particle) => {
    if (particle.type === "html" || particle.type === "text") {
      ImperativeTemplateGenerator[particle.type](particle, ctx);
      return;
    }
    throw new Error(`InstructionalTemplateGenerator: Unknown particle type: ${particle.type}`);
  };
  const ctx = {
    nodeIdx: 0,
    parentStack: [],
    addStmts: (stmts) => Array.isArray(stmts) ? stmts.forEach((s) => statements.push(s)) : statements.push(stmts),
    next: visit
  };
  visit(template);
  statements.push(types2.returnStatement(types2.identifier(generateNodeName(ctx, 0))));
  return types2.callExpression(types2.functionExpression(null, [], types2.blockStatement(statements)), []);
};
function declareTextNode(nodeName, value, dependenciesNode) {
  return types2.variableDeclaration("const", [
    types2.variableDeclarator(
      types2.identifier(nodeName),
      types2.callExpression(types2.identifier(importMap.createTextNode), [value, dependenciesNode])
    )
  ]);
}
var ImperativeTemplateGenerator = {
  html: ({ tag, props, children }, ctx) => {
    const nodeName = generateNodeName(ctx);
    const tagName = types2.isStringLiteral(tag) ? tag.value : "ANY";
    const nodeDeclareStatement = declareHTMLNode(nodeName, tag);
    const propsAssignStatements = Object.entries(props).map(([key, { value }]) => {
      return setHTMLProp(nodeName, tagName, key, value, 0, null);
    }).filter(Boolean);
    ctx.addStmts([nodeDeclareStatement, ...propsAssignStatements]);
    if (ctx.parentStack.length > 0) {
      ctx.addStmts(appendChild(ctx.parentStack[ctx.parentStack.length - 1], nodeName));
    }
    ctx.parentStack.push(nodeName);
    children.forEach((child) => {
      ctx.next(child);
    });
    ctx.parentStack.pop();
  },
  text: ({ content }, ctx) => {
    const nodeName = generateNodeName(ctx);
    const nodeDeclareStatement = declareTextNode(nodeName, content.value, content.dependenciesNode);
    ctx.addStmts(nodeDeclareStatement);
    if (ctx.parentStack.length > 0) {
      ctx.addStmts(appendChild(ctx.parentStack[ctx.parentStack.length - 1], nodeName));
    }
  }
};
function generateNodeName2(nodeIdx, tag) {
  return `${tag}${nodeIdx}`;
}
function genPropsUpdater(props, ctx) {
  if (props.length === 0) {
    return types2.nullLiteral();
  }
  const nodeMap = {};
  const nodeDeclareStatements = [];
  let nodeIdx = 0;
  const templateNodeId = types2.identifier("tpl");
  const propsAssignments = props.map(({ tag, path: path2, key, value, depIdBitmap, dependenciesNode }) => {
    const pathString = path2.join(".");
    let nodeName = nodeMap[pathString];
    if (!nodeName) {
      nodeName = generateNodeName2(nodeIdx++, tag);
      nodeDeclareStatements.push(
        types2.variableDeclaration("const", [
          types2.variableDeclarator(
            types2.identifier(nodeName),
            types2.callExpression(types2.identifier(importMap.templateGetElement), [
              templateNodeId,
              ...path2.map((p) => types2.numericLiteral(p))
            ])
          )
        ])
      );
      nodeMap[pathString] = nodeName;
    }
    ctx.wrapUpdate(value);
    return setHTMLProp(nodeName, tag, key, value, ctx.getReactBits(depIdBitmap), dependenciesNode);
  });
  return types2.arrowFunctionExpression(
    [templateNodeId],
    types2.blockStatement([
      ...nodeDeclareStatements,
      types2.returnStatement(types2.arrowFunctionExpression([], types2.blockStatement(propsAssignments)))
    ])
  );
}
function genMutableParticlesUpdater(mutableParticles, ctx) {
  return mutableParticles.map((particle) => {
    const { path: path2 } = particle;
    const lastIdx = path2[path2.length - 1];
    return types2.arrayExpression([
      types2.numericLiteral(lastIdx),
      ctx.next(particle),
      ...path2.slice(0, -1).map((p) => types2.numericLiteral(p))
    ]);
  });
}
var templateGenerator = {
  template: ({ template, props, mutableParticles }, ctx) => {
    const templateName = ctx.genTemplateKey();
    const templateContent = genTemplateContent(template);
    ctx.addTemplate(templateName, templateContent);
    const propsUpdater = genPropsUpdater(props, ctx);
    const mutableParticlesUpdater = genMutableParticlesUpdater(mutableParticles, ctx);
    return types2.callExpression(types2.identifier(importMap.createTemplateNode), [
      types2.identifier(templateName),
      propsUpdater,
      ...mutableParticlesUpdater
    ]);
  }
};
function genUpdateProp(nodeId, key, value, reactBits, dependenciesNode) {
  return types2.expressionStatement(
    types2.callExpression(types2.memberExpression(nodeId, types2.identifier("updateProp")), [
      types2.stringLiteral(key),
      types2.arrowFunctionExpression([], value),
      dependenciesNode,
      types2.numericLiteral(reactBits)
    ])
  );
}
var compGenerator = {
  comp: ({ tag, props, children }, ctx) => {
    if (types2.isIdentifier(tag) && tag.name === "Portal") {
      return createPortal(props, children, ctx);
    }
    const updateProps = [];
    const node = types2.identifier(nodeNameInUpdate);
    const properties = Object.entries(props).map(([key, { value, depIdBitmap, dependenciesNode }]) => {
      let initValue = value;
      if (key === "ref") {
        initValue = wrapRefHandler(value);
      }
      ctx.wrapUpdate(value);
      if (depIdBitmap) {
        updateProps.push(genUpdateProp(node, key, value, ctx.getReactBits(depIdBitmap), dependenciesNode));
      }
      return types2.objectProperty(types2.stringLiteral(key), initValue);
    });
    if (children.length) {
      const childrenNode = children.map((child) => ctx.next(child));
      properties.push(
        types2.objectProperty(
          types2.stringLiteral("children"),
          types2.callExpression(types2.identifier(importMap.createChildren), [
            types2.arrowFunctionExpression([], types2.arrayExpression(childrenNode)),
            types2.identifier("$$self")
          ])
        )
      );
    }
    const propsNode = types2.objectExpression(properties);
    const updater = updateProps.length ? types2.arrowFunctionExpression([node], types2.blockStatement(updateProps)) : types2.nullLiteral();
    return types2.callExpression(types2.identifier(importMap.createCompNode), [tag, propsNode, updater]);
  }
};
function createPortal(props, children, ctx) {
  return types2.callExpression(types2.identifier(importMap.createPortal), [
    types2.objectExpression(
      Object.entries(props).map(([key, { value }]) => {
        return types2.objectProperty(types2.stringLiteral(key), value);
      })
    ),
    ...children.map((child) => ctx.next(child))
  ]);
}
function wrapRefHandler(refVal) {
  const refInput = types2.identifier("$el");
  return types2.functionExpression(
    null,
    [refInput],
    types2.blockStatement([
      types2.expressionStatement(
        types2.conditionalExpression(
          types2.binaryExpression("===", types2.unaryExpression("typeof", refVal, true), types2.stringLiteral("function")),
          types2.callExpression(refVal, [refInput]),
          types2.assignmentExpression("=", refVal, refInput)
        )
      )
    ])
  );
}
var expGenerator = {
  exp: ({ content }, ctx) => {
    return types2.callExpression(types2.identifier(importMap.createExpNode), [
      types2.arrowFunctionExpression([], content.value),
      types2.arrowFunctionExpression([], content.dependenciesNode),
      types2.numericLiteral(ctx.getReactBits(content.depIdBitmap))
    ]);
  }
};
var fragmentGenerator = {
  fragment: ({ children }, ctx) => {
    return types2.callExpression(
      types2.identifier(importMap.createFragmentNode),
      children.map((child) => ctx.next(child))
    );
  }
};
var textGenerator = {
  text: ({ content }, ctx) => {
    const node = types2.identifier(nodeNameInUpdate);
    function textUpdater() {
      return types2.arrowFunctionExpression(
        [],
        types2.callExpression(types2.identifier(importMap.setText), [
          node,
          content.value,
          content.dependenciesNode,
          types2.numericLiteral(ctx.getReactBits(content.depIdBitmap))
        ])
      );
    }
    return types2.callExpression(
      types2.identifier(importMap.createTextNode),
      [content.value, content.depIdBitmap ? textUpdater() : null].filter(Boolean)
    );
  }
};
function geneCondCheck(node, idx) {
  return types2.ifStatement(
    types2.callExpression(types2.memberExpression(node, types2.identifier("branch")), [types2.numericLiteral(idx)]),
    types2.returnStatement(types2.arrayExpression([]))
  );
}
function geneIfStatement(test, body, alternate) {
  return types2.ifStatement(test, types2.blockStatement(body), alternate);
}
function geneCondReturnStatement(children, ctx) {
  return types2.returnStatement(types2.arrayExpression(children.map((p) => ctx.next(p))));
}
function geneCondition(node, idx, condition) {
  return types2.callExpression(types2.memberExpression(node, types2.identifier("cachedCondition")), [
    types2.numericLiteral(idx),
    types2.arrowFunctionExpression([], condition.value),
    condition.dependenciesNode
  ]);
}
var ifGenerator = {
  if: ({ branches }, ctx) => {
    const node = types2.identifier(nodeNameInUpdate);
    if (!types2.isBooleanLiteral(branches[branches.length - 1].condition.value, {
      value: true
    })) {
      branches.push({
        condition: {
          value: types2.booleanLiteral(true),
          depIdBitmap: 0,
          dependenciesNode: types2.arrayExpression([])
        },
        children: []
      });
    }
    let reactBits = 0;
    const ifStatement = branches.reverse().reduce((acc, { condition, children }, i) => {
      const idx = branches.length - i - 1;
      const childStatements = [geneCondCheck(node, idx), geneCondReturnStatement(children, ctx)];
      if (i === 0)
        return types2.blockStatement(childStatements);
      reactBits |= ctx.getReactBits(condition.depIdBitmap);
      return geneIfStatement(geneCondition(node, idx, condition), childStatements, acc);
    }, void 0);
    return types2.callExpression(types2.identifier(importMap.createConditionalNode), [
      types2.arrowFunctionExpression([node], types2.blockStatement([ifStatement])),
      types2.numericLiteral(reactBits)
    ]);
  }
};
var contextGenerator = {
  context: ({ contextName, props, children }, ctx) => {
    let contextNode = types2.callExpression(types2.identifier(importMap.createContextNode), [types2.identifier(contextName)]);
    if (Object.keys(props).length > 0) {
      const nodeId = types2.identifier(nodeNameInUpdate);
      const updateFunction = types2.arrowFunctionExpression(
        [nodeId],
        types2.blockStatement(
          Object.entries(props).map(
            ([key, prop]) => types2.expressionStatement(
              types2.callExpression(types2.memberExpression(nodeId, types2.identifier("updateContext")), [
                types2.stringLiteral(key),
                types2.arrowFunctionExpression([], prop.value),
                prop.dependenciesNode,
                types2.numericLiteral(ctx.getReactBits(prop.depIdBitmap))
              ])
            )
          )
        )
      );
      contextNode.arguments.push(updateFunction);
    }
    if (children.length > 0) {
      contextNode = types2.callExpression(
        types2.memberExpression(contextNode, types2.identifier("with")),
        children.map((child) => ctx.next(child))
      );
    }
    return contextNode;
  }
};
var suspenseGenerator = {
  suspense: ({ children, fallback }, ctx) => {
    let childrenNode = [];
    if (children.length > 0) {
      childrenNode = children.map((child) => ctx.next(child));
    }
    let fallbackNode = types2.nullLiteral();
    if (fallback) {
      fallbackNode = fallback.value;
    }
    const suspenseNode = types2.callExpression(types2.identifier(importMap.createSuspenseNode), []);
    const fallbacked = types2.callExpression(types2.memberExpression(suspenseNode, types2.identifier("fallback")), [
      types2.arrowFunctionExpression([], fallbackNode)
    ]);
    return types2.callExpression(types2.memberExpression(fallbacked, types2.identifier("with")), [types2.arrayExpression(childrenNode)]);
  }
};
var generators = [
  htmlGenerator,
  textGenerator,
  ifGenerator,
  forGenerator,
  templateGenerator,
  compGenerator,
  expGenerator,
  fragmentGenerator,
  contextGenerator,
  suspenseGenerator
];
function mergeViewGenerators(generators2) {
  return generators2.reduce((acc, generator) => __spreadValues(__spreadValues({}, acc), generator), {});
}
function generateView(viewParticle, config) {
  const viewGenerator2 = mergeViewGenerators(generators);
  const visit = (viewParticle2) => {
    const generator = viewGenerator2[viewParticle2.type];
    if (!generator) {
      throw new Error(`No generator for view particle type: ${viewParticle2.type}`);
    }
    return generator(viewParticle2, {
      wrapUpdate: config.wrapUpdate,
      getReactBits: config.getReactBits,
      importMap: config.importMap,
      addTemplate: (templateName, value) => {
        config.templates.push([templateName, value]);
      },
      genTemplateKey: () => config.genTemplateKey(prefixMap.template),
      next: visit
    });
  };
  return runWithConfig(config, () => visit(viewParticle));
}

// ../babel-inula-next-core/dist/index.js
var COMPONENT = "Component";
var HOOK = "Hook";
var WILL_MOUNT = "willMount";
var DID_MOUNT = "didMount";
var WILL_UNMOUNT = "willUnmount";
var DID_UNMOUNT = "didUnmount";
var WATCH = "watch";
var CURRENT_COMPONENT = "$$self";
var PropType = /* @__PURE__ */ ((PropType2) => {
  PropType2["REST"] = "restProp";
  PropType2["SINGLE"] = "singleProp";
  PropType2["WHOLE"] = "wholeProp";
  return PropType2;
})(PropType || {});
function isPropStmt(stmt) {
  return Object.values(PropType).includes(stmt.type);
}
var reactivityFuncNames = [
  // ---- Array
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse",
  // ---- Set
  "add",
  "delete",
  "clear",
  // ---- Map
  "set",
  "delete",
  "clear"
];
var USE_CONTEXT = "useContext";
var API_NAMES = [
  "createElement",
  "setStyle",
  "setDataset",
  "setEvent",
  "delegateEvent",
  "setHTMLProp",
  "setHTMLAttr",
  "setHTMLProps",
  "setHTMLAttrs",
  "createTextNode",
  "updateText",
  "insertNode",
  "appendNode",
  "render",
  "notCached",
  "useHook",
  "createHook",
  "untrack",
  "runOnce",
  "createNode",
  "updateNode",
  "updateChildren",
  "setProp",
  "setRef",
  "initContextChildren",
  "initCompNode",
  "emitUpdate",
  "compBuilder",
  "hookBuilder",
  "createCompNode",
  "createHTMLNode",
  "createFragmentNode",
  "createForNode",
  "createConditionalNode",
  "templateGetElement",
  "createTemplateNode",
  "createTextNode",
  "createExpNode",
  "createContextNode",
  "createSuspenseNode",
  "createPortal",
  "setText",
  "withDefault",
  "useContext",
  "createChildren",
  "setHTMLAttrs"
];
var originalImportMap = Object.fromEntries(API_NAMES.map((name2) => [name2, `$$${name2}`]));
var accessedKeys = /* @__PURE__ */ new Set();
var importMap2 = new Proxy(originalImportMap, {
  get(target, prop, receiver) {
    accessedKeys.add(prop);
    return Reflect.get(target, prop, receiver);
  }
});
function getAccessedKeys() {
  return Array.from(accessedKeys).reduce((map, key) => {
    map[key] = originalImportMap[key];
    return map;
  }, {});
}
function resetAccessedKeys() {
  accessedKeys.clear();
}
var alterAttributeMap2 = {
  class: "className",
  for: "htmlFor"
};
var defaultAttributeMap = {
  // ---- Other property as attribute
  textContent: ["*"],
  innerHTML: ["*"],
  // ---- Source: https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes
  accept: ["form", "input"],
  // ---- Original: accept-charset
  acceptCharset: ["form"],
  accesskey: ["*"],
  action: ["form"],
  align: ["caption", "col", "colgroup", "hr", "iframe", "img", "table", "tbody", "td", "tfoot", "th", "thead", "tr"],
  allow: ["iframe"],
  alt: ["area", "img", "input"],
  async: ["script"],
  autocapitalize: ["*"],
  autocomplete: ["form", "input", "select", "textarea"],
  autofocus: ["button", "input", "select", "textarea"],
  autoplay: ["audio", "video"],
  background: ["body", "table", "td", "th"],
  // ---- Original: base
  bgColor: ["body", "col", "colgroup", "marquee", "table", "tbody", "tfoot", "td", "th", "tr"],
  border: ["img", "object", "table"],
  buffered: ["audio", "video"],
  capture: ["input"],
  charset: ["meta"],
  checked: ["input"],
  cite: ["blockquote", "del", "ins", "q"],
  className: ["*"],
  color: ["font", "hr"],
  cols: ["textarea"],
  // ---- Original: colspan
  colSpan: ["td", "th"],
  content: ["meta"],
  // ---- Original: contenteditable
  contentEditable: ["*"],
  contextmenu: ["*"],
  controls: ["audio", "video"],
  coords: ["area"],
  crossOrigin: ["audio", "img", "link", "script", "video"],
  csp: ["iframe"],
  data: ["object"],
  // ---- Original: datetime
  dateTime: ["del", "ins", "time"],
  decoding: ["img"],
  default: ["track"],
  defer: ["script"],
  dir: ["*"],
  dirname: ["input", "textarea"],
  disabled: ["button", "fieldset", "input", "optgroup", "option", "select", "textarea"],
  download: ["a", "area"],
  draggable: ["*"],
  enctype: ["form"],
  // ---- Original: enterkeyhint
  enterKeyHint: ["textarea", "contenteditable"],
  htmlFor: ["label", "output"],
  form: ["button", "fieldset", "input", "label", "meter", "object", "output", "progress", "select", "textarea"],
  // ---- Original: formaction
  formAction: ["input", "button"],
  // ---- Original: formenctype
  formEnctype: ["button", "input"],
  // ---- Original: formmethod
  formMethod: ["button", "input"],
  // ---- Original: formnovalidate
  formNoValidate: ["button", "input"],
  // ---- Original: formtarget
  formTarget: ["button", "input"],
  headers: ["td", "th"],
  height: ["canvas", "embed", "iframe", "img", "input", "object", "video"],
  hidden: ["*"],
  high: ["meter"],
  href: ["a", "area", "base", "link"],
  hreflang: ["a", "link"],
  // ---- Original: http-equiv
  httpEquiv: ["meta"],
  id: ["*"],
  integrity: ["link", "script"],
  // ---- Original: intrinsicsize
  intrinsicSize: ["img"],
  // ---- Original: inputmode
  inputMode: ["textarea", "contenteditable"],
  ismap: ["img"],
  // ---- Original: itemprop
  itemProp: ["*"],
  kind: ["track"],
  label: ["optgroup", "option", "track"],
  lang: ["*"],
  language: ["script"],
  loading: ["img", "iframe"],
  list: ["input"],
  loop: ["audio", "marquee", "video"],
  low: ["meter"],
  manifest: ["html"],
  max: ["input", "meter", "progress"],
  // ---- Original: maxlength
  maxLength: ["input", "textarea"],
  // ---- Original: minlength
  minLength: ["input", "textarea"],
  media: ["a", "area", "link", "source", "style"],
  method: ["form"],
  min: ["input", "meter"],
  multiple: ["input", "select"],
  muted: ["audio", "video"],
  name: [
    "button",
    "form",
    "fieldset",
    "iframe",
    "input",
    "object",
    "output",
    "select",
    "textarea",
    "map",
    "meta",
    "param"
  ],
  // ---- Original: novalidate
  noValidate: ["form"],
  open: ["details", "dialog"],
  optimum: ["meter"],
  pattern: ["input"],
  ping: ["a", "area"],
  placeholder: ["input", "textarea"],
  // ---- Original: playsinline
  playsInline: ["video"],
  poster: ["video"],
  preload: ["audio", "video"],
  readonly: ["input", "textarea"],
  // ---- Original: referrerpolicy
  referrerPolicy: ["a", "area", "iframe", "img", "link", "script"],
  rel: ["a", "area", "link"],
  required: ["input", "select", "textarea"],
  reversed: ["ol"],
  role: ["*"],
  rows: ["textarea"],
  // ---- Original: rowspan
  rowSpan: ["td", "th"],
  sandbox: ["iframe"],
  scope: ["th"],
  scoped: ["style"],
  selected: ["option"],
  shape: ["a", "area"],
  size: ["input", "select"],
  sizes: ["link", "img", "source"],
  slot: ["*"],
  span: ["col", "colgroup"],
  spellcheck: ["*"],
  src: ["audio", "embed", "iframe", "img", "input", "script", "source", "track", "video"],
  srcdoc: ["iframe"],
  srclang: ["track"],
  srcset: ["img", "source"],
  start: ["ol"],
  step: ["input"],
  style: ["*"],
  summary: ["table"],
  // ---- Original: tabindex
  tabIndex: ["*"],
  target: ["a", "area", "base", "form"],
  title: ["*"],
  translate: ["*"],
  type: ["button", "input", "embed", "object", "ol", "script", "source", "style", "menu", "link"],
  usemap: ["img", "input", "object"],
  value: [
    "button",
    "data",
    "input",
    "li",
    "meter",
    "option",
    "progress",
    "param",
    "text"
    /** extra for TextNode */
  ],
  width: ["canvas", "embed", "iframe", "img", "input", "object", "video"],
  wrap: ["textarea"],
  // --- ARIA attributes
  //     Source: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes
  ariaAutocomplete: ["*"],
  ariaChecked: ["*"],
  ariaDisabled: ["*"],
  ariaErrorMessage: ["*"],
  ariaExpanded: ["*"],
  ariaHasPopup: ["*"],
  ariaHidden: ["*"],
  ariaInvalid: ["*"],
  ariaLabel: ["*"],
  ariaLevel: ["*"],
  ariaModal: ["*"],
  ariaMultiline: ["*"],
  ariaMultiSelectable: ["*"],
  ariaOrientation: ["*"],
  ariaPlaceholder: ["*"],
  ariaPressed: ["*"],
  ariaReadonly: ["*"],
  ariaRequired: ["*"],
  ariaSelected: ["*"],
  ariaSort: ["*"],
  ariaValuemax: ["*"],
  ariaValuemin: ["*"],
  ariaValueNow: ["*"],
  ariaValueText: ["*"],
  ariaBusy: ["*"],
  ariaLive: ["*"],
  ariaRelevant: ["*"],
  ariaAtomic: ["*"],
  ariaDropEffect: ["*"],
  ariaGrabbed: ["*"],
  ariaActiveDescendant: ["*"],
  ariaColCount: ["*"],
  ariaColIndex: ["*"],
  ariaColSpan: ["*"],
  ariaControls: ["*"],
  ariaDescribedBy: ["*"],
  ariaDescription: ["*"],
  ariaDetails: ["*"],
  ariaFlowTo: ["*"],
  ariaLabelledBy: ["*"],
  ariaOwns: ["*"],
  ariaPosInset: ["*"],
  ariaRowCount: ["*"],
  ariaRowIndex: ["*"],
  ariaRowSpan: ["*"],
  ariaSetSize: ["*"]
};
var defaultHTMLTags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "slot",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "acronym",
  "applet",
  "basefont",
  "bgsound",
  "big",
  "blink",
  "center",
  "dir",
  "font",
  "frame",
  "frameset",
  "isindex",
  "keygen",
  "listing",
  "marquee",
  "menuitem",
  "multicol",
  "nextid",
  "nobr",
  "noembed",
  "noframes",
  "param",
  "plaintext",
  "rb",
  "rtc",
  "spacer",
  "strike",
  "tt",
  "xmp",
  "animate",
  "animateMotion",
  "animateTransform",
  "circle",
  "clipPath",
  "defs",
  "desc",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "metadata",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "set",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  "tspan",
  "use",
  "view"
];
var builtinHooks = ["useContext"];
var HOOK_USING_PREFIX = "use";
var PARAM_PROPS = "props";
var CTX_PROPS = "ctx";
function isValidPath(path2) {
  return !!path2.node;
}
function isStaticValue(node) {
  return types2.isLiteral(node) && !types2.isTemplateLiteral(node) || types2.isArrowFunctionExpression(node) || types2.isFunctionExpression(node);
}
function assertComponentNode(node) {
  if (node.type !== "comp" && node.type !== "subComp") {
    throw new CompilerError("Analyze: Should be component node", node.loc);
  }
}
function assertHookNode(node) {
  if (node.type !== "hook") {
    throw new CompilerError("Analyze: Should be hook node", node.loc);
  }
}
function isUseHook(node) {
  if (types2.isCallExpression(node)) {
    const callee = node.callee;
    return types2.isIdentifier(callee) && callee.name.startsWith(HOOK_USING_PREFIX) && !builtinHooks.includes(callee.name);
  }
  return false;
}
function fileAllowed(fileName, includes, excludes) {
  if (includes.includes("*"))
    return true;
  if (!fileName)
    return false;
  if (excludes.some((pattern) => minimatch(fileName, pattern)))
    return false;
  return includes.some((pattern) => minimatch(fileName, pattern));
}
function addImport(programNode, importMap22, packageName) {
  programNode.body.unshift(
    types2.importDeclaration(
      Object.entries(importMap22).map(([key, value]) => types2.importSpecifier(types2.identifier(value), types2.identifier(key))),
      types2.stringLiteral(packageName)
    )
  );
}
function toArray(val) {
  return Array.isArray(val) ? val : [val];
}
function extractFnFromMacro(path2, macroName) {
  const args = path2.get("arguments");
  const fnNode = args[0];
  if (fnNode.isFunctionExpression() || fnNode.isArrowFunctionExpression()) {
    return fnNode;
  }
  throw new CompilerError(`${macroName} macro must have a function argument`, path2.node.loc);
}
function isFnExp(node) {
  return types2.isFunctionExpression(node) || types2.isArrowFunctionExpression(node);
}
function getFnBodyPath(path2) {
  const fnBody = path2.get("body");
  if (fnBody.isExpression()) {
    fnBody.replaceWith(types2.blockStatement([types2.returnStatement(fnBody.node)]));
  }
  return fnBody;
}
function getFnBodyNode(node) {
  const fnBody = node.body;
  if (types2.isExpression(fnBody)) {
    return types2.blockStatement([types2.returnStatement(fnBody)]);
  }
  return fnBody;
}
function isCompPath(path2) {
  const callee = path2.get("callee");
  return callee.isIdentifier() && callee.node.name === COMPONENT;
}
function isUseContext(path2) {
  const callee = path2.get("callee");
  return callee.isIdentifier() && callee.node.name === USE_CONTEXT;
}
function isHookPath(path2) {
  const callee = path2.get("callee");
  return callee.isIdentifier() && callee.node.name === HOOK;
}
function getMacroType(path2) {
  if (isCompPath(path2)) {
    return COMPONENT;
  }
  if (isHookPath(path2)) {
    return HOOK;
  }
  return null;
}
function createMacroNode(fnBody, macroName, params = []) {
  return types2.callExpression(types2.identifier(macroName), [types2.arrowFunctionExpression(params, fnBody)]);
}
function isValidPath2(path2) {
  return !!path2.node;
}
function bitmapToIndices(bitmap) {
  if (bitmap === 0)
    return [];
  if (bitmap < 0)
    throw new Error("Negative numbers are not supported");
  const indices = [];
  let currentBit = 0;
  while (bitmap > 0) {
    if (bitmap & 1) {
      indices.push(1 << currentBit);
    }
    bitmap = bitmap >>> 1;
    currentBit++;
  }
  return indices;
}
function mergeVisitor(...visitors) {
  return visitors.reduce((acc, cur) => {
    return __spreadValues(__spreadValues({}, acc), cur());
  }, {});
}
function assertIdOrDeconstruct(id, error) {
  if (!id.isIdentifier() && !id.isObjectPattern() && !id.isArrayPattern()) {
    throw new Error(error);
  }
}
function parseDestructuring(path2, dispatch) {
  if (path2.isObjectPattern()) {
    path2.get("properties").forEach((prop) => {
      if (prop.isRestElement()) {
        const arg = prop.get("argument");
        if (!Array.isArray(arg) && arg.isIdentifier()) {
          dispatch({ type: "rest", name: arg.node.name });
          return;
        }
        throw new CompilerError("Unsupported rest element type in object destructuring", prop.node.loc);
      } else if (prop.isObjectProperty()) {
        const key = prop.node.key;
        if (types2.isIdentifier(key) || types2.isStringLiteral(key)) {
          const name2 = types2.isIdentifier(key) ? key.name : key.value;
          dispatch({ type: "single", name: name2, value: prop.get("value"), node: prop.node });
          return;
        }
        throw new CompilerError(`Unsupported key type in object destructuring: ${key.type}`, prop.node.loc);
      }
    });
  } else if (path2.isIdentifier()) {
    dispatch({ type: "props", name: path2.node.name, node: path2.node });
  } else {
    throw new CompilerError(
      `Component ${name}: The first parameter of the function component must be an object pattern or identifier`,
      path2.node.loc
    );
  }
}
function variablesAnalyze() {
  return {
    VariableDeclaration(path2, ctx) {
      const { builder } = ctx;
      const declarations = path2.get("declarations");
      declarations.forEach((declaration) => {
        const id = declaration.get("id");
        const init = declaration.get("init");
        const kind = path2.node.kind;
        if (kind === "const" && isStaticValue(init.node)) {
          builder.addRawStmt(path2.node);
          return;
        }
        if (!isValidPath(init)) {
          assertIdentifier(id);
          resolveUninitializedVariable(kind, builder, id, declaration.node);
          return;
        }
        assertIdOrDeconstruct(id, "Invalid Variable type when adding variable: " + id.type);
        if (init.isCallExpression() && isCompPath(init)) {
          assertIdentifier(id);
          resolveSubComponent(init, builder, id, ctx);
          return;
        }
        if (init.isCallExpression() && isUseContext(init)) {
          const context = init.get("arguments")[0];
          assertIdentifier(context);
          builder.addContext(id, context.node);
          parseDestructuring(id, (payload) => {
            if (payload.type === "rest") {
              builder.addRestProps(payload.name, CTX_PROPS, context.node.name);
            } else if (payload.type === "single") {
              builder.addSingleProp(payload.name, payload.value, CTX_PROPS, context.node.name);
            } else if (payload.type === "props") {
              builder.addProps(payload.name, payload.node, CTX_PROPS, context.node.name);
            }
          });
          return;
        }
        builder.addVariable({
          id,
          value: init.node,
          kind: path2.node.kind,
          node: declaration.node
        });
      });
    },
    FunctionDeclaration(path2, { builder }) {
      builder.addRawStmt(path2.node);
    }
  };
}
function assertIdentifier(id) {
  if (!id.isIdentifier()) {
    throw new CompilerError(`${id.node.type} is not valid initial value type for state`, id.node.loc);
  }
}
function resolveUninitializedVariable(kind, builder, id, node) {
  if (kind === "const") {
    builder.addRawStmt(types2.variableDeclaration("const", [node]));
  }
  builder.addVariable({
    id,
    value: null,
    node,
    kind
  });
}
function resolveSubComponent(init, builder, id, ctx) {
  const fnNode = init.get("arguments")[0];
  builder.startSubComponent(id.node.name, fnNode);
  analyzeUnitOfWork(id.node.name, fnNode, ctx);
  builder.endSubComponent();
}
function isLifeCycleName(name2) {
  return [WILL_MOUNT, DID_MOUNT, WILL_UNMOUNT, DID_UNMOUNT].includes(name2);
}
function functionalMacroAnalyze() {
  return {
    ExpressionStatement(path2, { builder }) {
      const expression = path2.get("expression");
      if (expression.isCallExpression()) {
        const callee = expression.get("callee");
        if (callee.isIdentifier()) {
          const calleeName = callee.node.name;
          if (isLifeCycleName(calleeName)) {
            const fnPath = extractFnFromMacro(expression, calleeName);
            builder.addLifecycle(calleeName, fnPath);
            return;
          }
          if (calleeName === WATCH) {
            const fnPath = extractFnFromMacro(expression, WATCH);
            const depsPath = getWatchDeps(expression);
            const dependency = builder.getDependency((depsPath != null ? depsPath : fnPath).node);
            builder.addWatch(fnPath, dependency);
            return;
          }
        }
      }
      builder.addRawStmt(path2.node);
    }
  };
}
function getWatchDeps(callExpression) {
  const args = callExpression.get("arguments");
  if (!args[1]) {
    return null;
  }
  let deps = null;
  if (args[1].isArrayExpression()) {
    deps = args[1];
  } else {
    console.error("watch deps should be an array expression");
  }
  return deps;
}
function isAssignmentExpression(path2) {
  let parentPath = path2.parentPath;
  while (parentPath && !types2.isStatement(parentPath.node)) {
    if (parentPath.isAssignmentExpression()) {
      if (parentPath.node.left === path2.node)
        return parentPath;
      const leftPath = parentPath.get("left");
      if (path2.isDescendant(leftPath))
        return parentPath;
    } else if (parentPath.isUpdateExpression()) {
      return parentPath;
    }
    parentPath = parentPath.parentPath;
  }
  return null;
}
function wrapUpdate(selfId, node, getWaveBits2) {
  if (!node)
    return;
  const addWave = (node2, bit) => {
    const bitNode = types2.numericLiteral(bit);
    types2.addComment(bitNode, "trailing", `0b${bit.toString(2)}`, false);
    return types2.callExpression(types2.memberExpression(selfId, types2.identifier("wave")), [node2, bitNode]);
  };
  traverse(nodeWrapFile(node), {
    Identifier: (path2) => {
      if (!getWaveBits2(path2.node.name))
        return;
      const assignmentPath = isAssignmentExpression(path2);
      if (!assignmentPath)
        return;
      const assignmentNode = assignmentPath.node;
      const writingNode = extractWritingPart(assignmentNode);
      if (!writingNode)
        return;
      let allBits = 0;
      traverse(nodeWrapFile(writingNode), {
        Identifier: (path22) => {
          allBits |= getWaveBits2(path22.node.name);
        }
      });
      assignmentPath.replaceWith(addWave(assignmentNode, allBits));
      assignmentPath.skip();
    },
    CallExpression: (path2) => {
      if (!types2.isMemberExpression(path2.node.callee))
        return;
      const funcNameNode = path2.node.callee.property;
      if (!types2.isIdentifier(funcNameNode))
        return;
      if (!reactivityFuncNames.includes(funcNameNode.name))
        return;
      let callee = path2.get("callee").get("object");
      while (callee.isMemberExpression()) {
        callee = callee.get("object");
      }
      if (callee.isIdentifier()) {
        const key = callee.node.name;
        const waveBits = getWaveBits2(key);
        if (!waveBits)
          return;
        path2.replaceWith(addWave(path2.node, waveBits));
      }
      path2.skip();
    }
  });
}
function extractWritingPart(assignmentNode) {
  if (types2.isUpdateExpression(assignmentNode)) {
    return assignmentNode.argument;
  } else if (types2.isAssignmentExpression(assignmentNode)) {
    return types2.assignmentExpression("=", assignmentNode.left, types2.stringLiteral(""));
  }
  return null;
}
function nodeWrapFile(node) {
  return types2.file(types2.program([types2.isStatement(node) ? node : types2.expressionStatement(node)]));
}
function viewAnalyze() {
  return {
    ReturnStatement(path2, { builder }) {
      const returnedPath = path2.get("argument");
      if (returnedPath.isJSXElement() || returnedPath.isJSXFragment()) {
        builder.setViewChild(returnedPath.node);
      } else if (returnedPath.isExpression() && hasVariables(returnedPath.node)) {
        builder.setViewChild(types2.jsxExpressionContainer(returnedPath.node));
      } else if (returnedPath.isStringLiteral() || returnedPath.isNumericLiteral() || returnedPath.isBooleanLiteral()) {
        builder.setViewChild(types2.jsxText(returnedPath.node.value.toString()));
      } else if (returnedPath.node === null || returnedPath.isNullLiteral()) {
        builder.setEmptyView();
      }
    }
  };
}
function hasVariables(expression) {
  let hasVar = false;
  const visitor = {
    Identifier(path2) {
      if (path2.isReferencedIdentifier()) {
        hasVar = true;
        path2.stop();
      }
    }
  };
  traverse(nodeWrapFile(expression), visitor);
  return hasVar;
}
function hookReturnAnalyze() {
  return {
    ReturnStatement(path2, { builder }) {
      const returnedNode = path2.node.argument;
      if (returnedNode) {
        builder.setReturnValue(returnedNode);
      }
    }
  };
}
function createIRNode(name2, type, fnNode, parent) {
  const parentScope = parent == null ? void 0 : parent.scope;
  const comp = {
    type: type === COMPONENT ? "comp" : "hook",
    params: fnNode.node.params,
    name: name2,
    body: [
      {
        type: "init"
      }
    ],
    parent,
    fnNode,
    scope: createScope(parentScope)
  };
  return comp;
}
function createScope(parentScope) {
  return {
    level: parentScope ? parentScope.level + 1 : 0,
    reactiveMap: /* @__PURE__ */ new Map(),
    usedIdBits: 0
  };
}
function pruneUnusedState(comp, idMap, bitIndex = -1) {
  const reactiveMap = comp.scope.reactiveMap;
  const usedIdBits = comp.scope.usedIdBits;
  let preId;
  Array.from(reactiveMap).forEach(([, idBit]) => {
    if (usedIdBits & idBit) {
      if (preId !== idBit) {
        bitIndex++;
      }
      idMap.set(idBit, 1 << bitIndex);
    }
    preId = idBit;
  });
  for (const stmt of comp.body) {
    if (stmt.type === "subComp") {
      bitIndex = pruneUnusedState(stmt.component, idMap, bitIndex);
    }
  }
  return bitIndex;
}
function trackSource(waveBitsMap, stmt, ownBit) {
  const downstreamWaveBits = waveBitsMap.get(stmt.reactiveId);
  const derivedWaves = downstreamWaveBits ? downstreamWaveBits | ownBit : ownBit;
  if (stmt.dependency) {
    bitmapToIndices(stmt.dependency.depIdBitmap).forEach((id) => {
      const waveBits = waveBitsMap.get(id);
      if (waveBits) {
        waveBitsMap.set(id, waveBits | derivedWaves);
      } else {
        waveBitsMap.set(id, derivedWaves);
      }
    });
  }
}
function getWaveBits(idToWaveBitMap, stmt, waveBitsMap) {
  var _a2;
  const ownBit = idToWaveBitMap.get(stmt.reactiveId);
  let waveBits = ownBit;
  if (ownBit) {
    const downstreamWaveBits = (_a2 = waveBitsMap.get(stmt.reactiveId)) != null ? _a2 : 0;
    waveBits = ownBit | downstreamWaveBits;
  }
  return waveBits;
}
var _current, _htmlTags, _a;
var IRBuilder = (_a = class {
  constructor(name2, type, fnNode, htmlTags) {
    __privateAdd(this, _current);
    __privateAdd(this, _htmlTags);
    __publicField(this, "reactiveIndex", 0);
    __publicField(this, "getDependency", (node) => {
      return getDependenciesFromNode(node, this.getGlobalReactiveMap(), reactivityFuncNames);
    });
    __privateSet(this, _current, createIRNode(name2, type, fnNode));
    __privateSet(this, _htmlTags, htmlTags);
  }
  getNextId() {
    return 1 << this.reactiveIndex++;
  }
  addStmt(stmt) {
    __privateGet(this, _current).body.push(stmt);
  }
  addDeclaredReactive(name2, id) {
    const reactiveId = id != null ? id : this.getNextId();
    __privateGet(this, _current).scope.reactiveMap.set(name2, reactiveId);
    return reactiveId;
  }
  /**
   * Get tree level global reactive map
   */
  getGlobalReactiveMap() {
    const fullReactiveMap = new Map(__privateGet(this, _current).scope.reactiveMap);
    let next = __privateGet(this, _current).parent;
    while (next) {
      next.scope.reactiveMap.forEach((id, name2) => {
        if (!fullReactiveMap.has(name2)) {
          fullReactiveMap.set(name2, id);
        }
      });
      next = next.parent;
    }
    return fullReactiveMap;
  }
  addRawStmt(stmt) {
    this.addStmt({
      type: "raw",
      value: stmt
    });
  }
  addProps(name2, value, source = PARAM_PROPS, ctxName) {
    const reactiveId = this.addDeclaredReactive(name2);
    this.addStmt({
      name: name2,
      value,
      type: "wholeProp",
      reactiveId,
      source,
      ctxName
    });
  }
  addRestProps(name2, source = PARAM_PROPS, ctxName) {
    const reactiveId = this.addDeclaredReactive(name2);
    this.addStmt({
      name: name2,
      type: "restProp",
      reactiveId,
      source,
      ctxName
    });
  }
  addSingleProp(key, valPath, source = PARAM_PROPS, ctxName) {
    if (!valPath.isLVal()) {
      throw new CompilerError("Invalid Prop Value type: " + valPath.type, valPath.node.loc);
    }
    const reactiveId = this.getNextId();
    const destructured = getDestructure(valPath);
    let value = valPath.node;
    let defaultValue = null;
    if (destructured) {
      const destructuredNames = searchNestedProps(destructured);
      destructuredNames.forEach((name2) => this.addDeclaredReactive(name2, reactiveId));
    } else {
      let propName = key;
      if (valPath.isIdentifier() && valPath.node.name !== key) {
        propName = valPath.node.name;
      }
      if (valPath.isAssignmentPattern()) {
        const left = valPath.node.left;
        if (types2.isIdentifier(left) && left.name !== key) {
          propName = left.name;
        }
        value = left;
        defaultValue = valPath.node.right;
      }
      this.addDeclaredReactive(propName, reactiveId);
    }
    this.addStmt({
      name: key,
      reactiveId,
      value,
      type: "singleProp",
      isDestructured: !!destructured,
      defaultValue,
      source,
      ctxName
    });
  }
  addVariable(varInfo) {
    const id = varInfo.id;
    const reactiveId = this.getNextId();
    const varIds = this.parseIdInLVal(id, reactiveId);
    const value = varInfo.value;
    if (value) {
      const dependency = this.getDependency(value);
      if (isUseHook(value)) {
        if (dependency) {
          this.addUsedReactives(dependency.depIdBitmap);
        }
        this.addStmt({
          type: "derived",
          ids: varIds,
          lVal: id.node,
          reactiveId,
          value,
          source: "hook",
          dependency,
          hookArgDependencies: getHookProps(value, this.getDependency)
        });
        return;
      }
      if (dependency) {
        this.addUsedReactives(dependency.depIdBitmap);
        this.addStmt({
          type: "derived",
          ids: varIds,
          lVal: id.node,
          reactiveId,
          value,
          source: "state",
          dependency
        });
        return;
      }
    }
    this.addStmt({
      type: "state",
      name: id.node,
      value,
      reactiveId,
      node: varInfo.node
    });
  }
  parseIdInLVal(id, reactiveId) {
    let varIds = [];
    if (id.isIdentifier()) {
      const name2 = id.node.name;
      this.addDeclaredReactive(name2, reactiveId);
      varIds.push(name2);
    } else if (id.isObjectPattern() || id.isArrayPattern()) {
      const destructuredNames = searchNestedProps(id);
      destructuredNames.forEach((name2) => {
        this.addDeclaredReactive(name2, reactiveId);
      });
      varIds = destructuredNames;
    }
    return varIds;
  }
  addContext(id, context) {
    assertIdOrDeconstruct(id, "Invalid Variable type when using context: " + id.type);
    this.addStmt({
      type: "useContext",
      lVal: id.node,
      context
    });
  }
  addUsedReactives(usedIdBits) {
    __privateGet(this, _current).scope.usedIdBits |= usedIdBits;
  }
  addSubComponent(subComp) {
    __privateGet(this, _current).scope.usedIdBits |= subComp.scope.usedIdBits;
    this.addStmt({
      type: "subComp",
      component: subComp,
      name: subComp.name
    });
  }
  addLifecycle(lifeCycle, callback) {
    this.addStmt({
      type: "lifecycle",
      lifeCycle,
      callback
    });
  }
  addWatch(callback, dependency) {
    if (dependency) {
      this.addUsedReactives(dependency.depIdBitmap);
    }
    this.addStmt({
      type: "watch",
      callback,
      dependency
    });
  }
  setViewChild(viewNode) {
    assertComponentNode(__privateGet(this, _current));
    const viewUnits = parseView(viewNode, {
      babelApi: getBabelApi(),
      htmlTags: __privateGet(this, _htmlTags),
      parseTemplate: false
    });
    const [viewParticle, useIdBits] = parseReactivity(viewUnits, {
      babelApi: getBabelApi(),
      reactiveMap: this.getGlobalReactiveMap(),
      reactivityFuncNames
    });
    this.addStmt({
      type: "viewReturn",
      value: viewParticle
    });
    this.addUsedReactives(useIdBits);
  }
  setEmptyView() {
    this.addStmt({
      type: "viewReturn",
      value: null
    });
  }
  setReturnValue(expression) {
    assertHookNode(__privateGet(this, _current));
    const dependency = this.getDependency(expression);
    if (dependency) {
      this.addUsedReactives(dependency.depIdBitmap);
    }
    this.addStmt(__spreadValues({
      type: "hookReturn",
      value: expression
    }, dependency));
  }
  checkSubComponent(subCompName) {
    return !!__privateGet(this, _current).body.find((sub) => sub.type === "subComp" && sub.name === subCompName);
  }
  startSubComponent(name2, fnNode) {
    assertComponentNode(__privateGet(this, _current));
    __privateSet(this, _current, createIRNode(name2, COMPONENT, fnNode, __privateGet(this, _current)));
  }
  endSubComponent() {
    const subComp = __privateGet(this, _current);
    __privateSet(this, _current, __privateGet(this, _current).parent);
    this.addSubComponent(subComp);
  }
  build() {
    const idToWaveBitMap = /* @__PURE__ */ new Map();
    pruneUnusedState(__privateGet(this, _current), idToWaveBitMap);
    const waveBitsMap = /* @__PURE__ */ new Map();
    function buildWaveMap(block) {
      for (let i = block.body.length - 1; i >= 0; i--) {
        const stmt = block.body[i];
        if (stmt.type === "state" || stmt.type === "derived" || isPropStmt(stmt)) {
          const waveBits = getWaveBits(idToWaveBitMap, stmt, waveBitsMap);
          if (waveBits) {
            waveBitsMap.set(stmt.reactiveId, waveBits);
            if (stmt.type === "derived") {
              trackSource(waveBitsMap, stmt, waveBits);
            }
          }
        }
      }
    }
    function traverse3(node) {
      node.body.forEach((stmt) => {
        if (stmt.type === "subComp") {
          traverse3(stmt.component);
        }
      });
      buildWaveMap(node);
    }
    traverse3(__privateGet(this, _current));
    return [__privateGet(this, _current), new BitManager(waveBitsMap, idToWaveBitMap)];
  }
}, _current = new WeakMap(), _htmlTags = new WeakMap(), _a);
var BitManager = class {
  constructor(waveBitsMap, idToWaveBitMap) {
    __publicField(this, "getWaveBits", (block, name2) => {
      var _a2;
      let current = block;
      while (current) {
        const id = current.scope.reactiveMap.get(name2);
        if (id) {
          return (_a2 = this.waveBitsMap.get(id)) != null ? _a2 : 0;
        }
        current = current.parent;
      }
      return 0;
    });
    __publicField(this, "getWaveBitsById", (id) => {
      var _a2;
      return (_a2 = this.waveBitsMap.get(id)) != null ? _a2 : 0;
    });
    __publicField(this, "getReactBits", (idBitmap) => {
      return bitmapToIndices(idBitmap).reduce((acc, depId) => {
        const waveBit = this.idToWaveBitMap.get(depId);
        if (waveBit) {
          return acc | waveBit;
        }
        throw new Error(`wave bit not found for id ${depId}`);
      }, 0);
    });
    this.waveBitsMap = waveBitsMap;
    this.idToWaveBitMap = idToWaveBitMap;
  }
};
function searchNestedProps(idPath) {
  const nestedProps = [];
  if (idPath.isObjectPattern() || idPath.isArrayPattern()) {
    idPath.traverse({
      Identifier(path2) {
        const parentPath = path2.parentPath;
        if (parentPath.isObjectProperty() && path2.parentKey === "value") {
          nestedProps.push(path2.node.name);
        } else if (parentPath.isArrayPattern() || parentPath.isObjectPattern() || parentPath.isRestElement() || parentPath.isAssignmentPattern() && path2.key === "left") {
          nestedProps.push(path2.node.name);
        }
      }
    });
  }
  return nestedProps;
}
function getDestructure(path2) {
  if (path2.isAssignmentPattern()) {
    const left = path2.get("left");
    if (left.isObjectPattern() || left.isArrayPattern()) {
      return left;
    }
  } else if (path2.isObjectPattern() || path2.isArrayPattern()) {
    return path2;
  }
  return null;
}
function getHookProps(value, getDependency) {
  const params = value.arguments;
  return params.map((param) => {
    if (types2.isSpreadElement(param)) {
      return getDependency(param.argument);
    }
    if (types2.isArgumentPlaceholder(param)) {
      return null;
    }
    return getDependency(param);
  });
}
function compPropsAnalyze() {
  return {
    Props: (path2, { builder }) => {
      const props = path2[0];
      const reducer = (payload) => {
        if (payload.type === "rest") {
          builder.addRestProps(payload.name);
        } else if (payload.type === "single") {
          builder.addSingleProp(payload.name, payload.value);
        } else if (payload.type === "props") {
          builder.addProps(payload.name, payload.node);
        }
      };
      parseDestructuring(props, reducer);
    }
  };
}
function hookPropsAnalyze() {
  return {
    Props: (path2, { builder }) => {
      path2.forEach((prop, idx) => {
        if (prop.isIdentifier()) {
          builder.addSingleProp(idx, prop);
        } else if (prop.isRestElement()) {
          const arg = prop.get("argument");
          if (!Array.isArray(arg) && arg.isIdentifier()) {
            builder.addRestProps(arg.node.name);
            return;
          }
          throw new CompilerError("Unsupported rest element type in hook props destructuring", prop.node.loc);
        } else {
          builder.addSingleProp(idx, prop);
        }
      });
    }
  };
}
var compBuiltinAnalyzers = [variablesAnalyze, functionalMacroAnalyze, viewAnalyze, compPropsAnalyze];
var hookBuiltinAnalyzers = [
  variablesAnalyze,
  functionalMacroAnalyze,
  hookReturnAnalyze,
  hookPropsAnalyze
];
function analyzeUnitOfWork(name2, fnNode, context) {
  var _a2;
  const { builder, analyzers } = context;
  const visitor = mergeVisitor(...analyzers);
  const params = fnNode.get("params");
  if (params.length > 0) {
    (_a2 = visitor.Props) == null ? void 0 : _a2.call(visitor, params, context);
  }
  const bodyStatements = getFnBodyPath(fnNode).get("body");
  for (let i = 0; i < bodyStatements.length; i++) {
    const path2 = bodyStatements[i];
    const type = path2.node.type;
    const visit = visitor[type];
    if (visit) {
      visit(path2, context);
    } else {
      builder.addRawStmt(path2.node);
    }
  }
}
function analyze(type, fnName, path2, options) {
  const analyzers = (options == null ? void 0 : options.customAnalyzers) ? options.customAnalyzers : getBuiltinAnalyzers(type);
  const builder = new IRBuilder(fnName, type, path2, options.htmlTags);
  analyzeUnitOfWork(fnName, path2, { builder, analyzers });
  return builder.build();
}
function getBuiltinAnalyzers(type) {
  if (type === COMPONENT) {
    return compBuiltinAnalyzers;
  }
  if (type === HOOK) {
    return hookBuiltinAnalyzers;
  }
  throw new Error("Unsupported type to analyze");
}
function stateGenerator() {
  return {
    state(stmt) {
      return types2.variableDeclaration("let", [stmt.node]);
    },
    /*
     * Derived includes two part:
     * - variable declarement
     * - upate call expression
     * e.g.
     * let double: any;
     * self.deriveState(() => double = count * 2, () => [count], 0b0010);
     *
     * self.useHook(Hook(), (val) => self.wave((double = val), waveBits), (hook) => {
     *   hook.updateProp('count', 100);
     *   hook.updateProp('count', () => count, [count], reactBits);
     * })
     */
    derived(stmt, ctx) {
      const { selfId, getReactBits, getWaveBitsById } = ctx;
      const derivedDeclaration = types2.variableDeclaration(
        "let",
        stmt.ids.map((id) => types2.variableDeclarator(types2.identifier(id)))
      );
      let updateCall;
      if (stmt.source === "hook") {
        const value = types2.identifier("$$value");
        updateCall = types2.expressionStatement(
          types2.callExpression(types2.memberExpression(selfId, types2.identifier("useHook")), [
            stmt.value,
            // update function
            types2.arrowFunctionExpression(
              [value],
              types2.callExpression(types2.memberExpression(selfId, types2.identifier("wave")), [
                types2.parenthesizedExpression(types2.assignmentExpression("=", stmt.lVal, value)),
                types2.numericLiteral(getWaveBitsById(stmt.reactiveId))
              ])
            ),
            // updater
            getHookUpdater(stmt.value, stmt.hookArgDependencies, ctx)
          ])
        );
      } else {
        updateCall = types2.expressionStatement(
          types2.callExpression(types2.memberExpression(selfId, types2.identifier("deriveState")), [
            // update function
            types2.arrowFunctionExpression(
              [],
              types2.parenthesizedExpression(types2.assignmentExpression("=", stmt.lVal, stmt.value))
            ),
            // dependencies node
            types2.arrowFunctionExpression([], stmt.dependency.dependenciesNode),
            // wave bits
            types2.numericLiteral(getReactBits(stmt.dependency.depIdBitmap))
          ])
        );
      }
      return [derivedDeclaration, updateCall];
    }
  };
}
function getHookUpdater(value, argDependencies, ctx) {
  const hook = types2.identifier("hook");
  const args = value.arguments;
  const updatePropsStmts = [];
  args.forEach((arg, idx) => {
    const dependency = argDependencies[idx];
    if (dependency) {
      let key = types2.numericLiteral(idx);
      if (types2.isRestElement(arg)) {
        key = types2.stringLiteral("rest");
      }
      let value2;
      if (types2.isSpreadElement(arg)) {
        value2 = arg.argument;
      } else if (types2.isExpression(arg)) {
        value2 = arg;
      } else {
        throw new Error("Invalid argument for hook function");
      }
      updatePropsStmts.push(
        types2.expressionStatement(
          types2.callExpression(types2.memberExpression(hook, types2.identifier("updateProp")), [
            key,
            types2.arrowFunctionExpression([], types2.isSpreadElement(arg) ? types2.identifier("$$value") : arg),
            dependency.dependenciesNode,
            types2.numericLiteral(ctx.getReactBits(dependency.depIdBitmap))
          ])
        )
      );
    }
  });
  return types2.arrowFunctionExpression([hook], types2.blockStatement(updatePropsStmts));
}
function viewGenerator() {
  return {
    viewReturn(stmt, ctx) {
      const templates = [];
      if (stmt.value === null) {
        return genReturnStmt(types2.nullLiteral(), ctx);
      }
      const view = generateView(stmt.value, {
        attributeMap: defaultAttributeMap,
        alterAttributeMap: alterAttributeMap2,
        getReactBits: ctx.getReactBits,
        importMap: ctx.importMap,
        templates,
        wrapUpdate: ctx.wrapUpdate,
        genTemplateKey: (name2) => {
          const programScope = ctx.current.fnNode.scope.getProgramParent();
          return programScope.generateUid(name2);
        }
      });
      ctx.hoist(
        templates.map(
          ([name2, expr]) => types2.variableDeclaration("const", [types2.variableDeclarator(types2.identifier(name2), expr)])
        )
      );
      return genReturnStmt(view, ctx);
    }
  };
}
function genReturnStmt(view, ctx) {
  const prepareCall = types2.callExpression(types2.memberExpression(ctx.selfId, types2.identifier("prepare")), []);
  return types2.returnStatement(types2.callExpression(types2.memberExpression(prepareCall, types2.identifier("init")), [view]));
}
function rawStmtGenerator() {
  return {
    raw(stmt, ctx) {
      ctx.wrapUpdate(stmt.value);
      return stmt.value;
    }
  };
}
function compGenerator2() {
  return {
    /**
     * const self = compBuilder()
     * @param stmt
     * @param ctx
     * @returns
     */
    init(stmt, { selfId, importMap: importMap22, parentId }) {
      const params = parentId ? [parentId] : [];
      return types2.variableDeclaration("const", [
        types2.variableDeclarator(selfId, types2.callExpression(types2.identifier(importMap22.compBuilder), params))
      ]);
    },
    subComp(stmt, ctx) {
      return generate(stmt.component, ctx.bitManager, ctx.hoist, ctx.selfId);
    }
  };
}
function functionalMacroGenerator() {
  return {
    /**
     * self.watch(() => {
     *  console.log(count);
     * }, () => [count], 0b1);
     * @param stmt
     * @returns
     */
    watch(stmt, { selfId, getWaveBits: getWaveBits2, getReactBits }) {
      var _a2, _b;
      const watchFnBody = stmt.callback.node;
      wrapUpdate(selfId, watchFnBody, getWaveBits2);
      return types2.expressionStatement(
        types2.callExpression(types2.memberExpression(selfId, types2.identifier("watch")), [
          watchFnBody,
          stmt.dependency ? types2.arrowFunctionExpression([], stmt.dependency.dependenciesNode) : types2.nullLiteral(),
          types2.numericLiteral(getReactBits((_b = (_a2 = stmt.dependency) == null ? void 0 : _a2.depIdBitmap) != null ? _b : 0))
        ])
      );
    },
    lifecycle(stmt, { selfId, getWaveBits: getWaveBits2 }) {
      const fnBody = stmt.callback.node;
      wrapUpdate(selfId, fnBody, getWaveBits2);
      return types2.expressionStatement(
        types2.callExpression(types2.memberExpression(selfId, types2.identifier(stmt.lifeCycle)), [fnBody])
      );
    }
  };
}
function propGenerator() {
  return {
    /**
     * self.addProp('name', value => name = value, 0b0001)
     * @param stmt
     * @param selfId
     * @param getWaveBitsById
     * @returns prop statement
     */
    [
      "singleProp"
      /* SINGLE */
    ](stmt, { selfId, getWaveBitsById }) {
      const valueId = types2.identifier("value");
      const right = stmt.defaultValue ? types2.callExpression(types2.identifier(importMap2.withDefault), [valueId, stmt.defaultValue]) : valueId;
      let valueAssign = types2.assignmentExpression("=", stmt.value, right);
      if (stmt.isDestructured) {
        valueAssign = types2.parenthesizedExpression(valueAssign);
      }
      return genAddPropStmt(
        selfId,
        stmt.name,
        valueId,
        valueAssign,
        getWaveBitsById(stmt.reactiveId),
        stmt.source,
        stmt.ctxName
      );
    },
    /**
     * self.addProp('$rest$', value => rest = { ...rest, ...value }, 0b0010)
     * @param stmt
     * @returns prop statement
     */
    [
      "restProp"
      /* REST */
    ](stmt, { selfId, getWaveBitsById }) {
      const valueId = types2.identifier("value");
      const valueAssign = types2.assignmentExpression(
        "=",
        types2.identifier(stmt.name),
        types2.objectExpression([types2.spreadElement(types2.identifier(stmt.name)), types2.spreadElement(valueId)])
      );
      return genAddPropStmt(
        selfId,
        "$rest$",
        valueId,
        valueAssign,
        getWaveBitsById(stmt.reactiveId),
        stmt.source,
        stmt.ctxName
      );
    },
    /**
     * self.addProp('$whole$', value => whole = { ...whole, ...value }, 0b0010)
     * @param stmt
     * @returns prop statement
     */
    [
      "wholeProp"
      /* WHOLE */
    ](stmt, { selfId, getWaveBitsById }) {
      const valueId = types2.identifier("value");
      const valueAssign = types2.assignmentExpression(
        "=",
        types2.identifier(stmt.name),
        types2.objectExpression([types2.spreadElement(types2.identifier(stmt.name)), types2.spreadElement(valueId)])
      );
      return genAddPropStmt(
        selfId,
        "$whole$",
        valueId,
        valueAssign,
        getWaveBitsById(stmt.reactiveId),
        stmt.source,
        stmt.ctxName
      );
    },
    /**
     * @example
     *   let {
     *    name, // 0b0001
     *    age,  // 0b0010
     *    contact: {phone, email}, // 0b0100
     *    // ...rest  // 0b1000
     *  } = useContext(UserContext, self);
     */
    useContext(stmt, { selfId }) {
      return types2.variableDeclaration("let", [
        types2.variableDeclarator(stmt.lVal, types2.callExpression(types2.identifier(importMap2.useContext), [stmt.context, selfId]))
      ]);
    }
  };
}
function genAddPropStmt(selfId, key, valueId, valueAssign, waveBits, source, ctxName) {
  const apiName = source === CTX_PROPS ? "addContext" : "addProp";
  const args = [
    typeof key === "string" ? types2.stringLiteral(key) : types2.numericLiteral(key),
    types2.arrowFunctionExpression([valueId], valueAssign),
    types2.numericLiteral(waveBits)
  ];
  if (ctxName) {
    args.unshift(types2.identifier(ctxName));
  }
  return types2.expressionStatement(types2.callExpression(types2.memberExpression(selfId, types2.identifier(apiName)), args));
}
function hookGenerator() {
  return {
    /**
     * const self = compBuilder()
     * @param stmt
     * @param ctx
     * @returns
     */
    init(stmt, { selfId, importMap: importMap22, parentId }) {
      const params = parentId ? [parentId] : [];
      return types2.variableDeclaration("const", [
        types2.variableDeclarator(selfId, types2.callExpression(types2.identifier(importMap22.hookBuilder), params))
      ]);
    },
    hookReturn(stmt, ctx) {
      const params = [types2.arrowFunctionExpression([], stmt.value)];
      if (stmt.dependenciesNode) {
        params.push(types2.arrowFunctionExpression([], stmt.dependenciesNode));
        params.push(types2.numericLiteral(ctx.getReactBits(stmt.depIdBitmap)));
      }
      return types2.returnStatement(types2.callExpression(types2.memberExpression(ctx.selfId, types2.identifier("init")), params));
    }
  };
}
var compBuiltinGenerators = [
  stateGenerator,
  rawStmtGenerator,
  propGenerator,
  viewGenerator,
  compGenerator2,
  rawStmtGenerator,
  functionalMacroGenerator
];
var hookBuiltinGenerators = [
  stateGenerator,
  rawStmtGenerator,
  propGenerator,
  hookGenerator,
  rawStmtGenerator,
  functionalMacroGenerator
];
function getBuiltinGenerators(type) {
  if (type === "comp") {
    return compBuiltinGenerators;
  }
  if (type === "hook") {
    return hookBuiltinGenerators;
  }
  throw new Error("Unsupported type to analyze");
}
function generate(root, bitManager, hoist, parentId) {
  const ctx = {
    selfId: generateSelfId2(root.scope.level),
    current: root,
    bitManager,
    hoist,
    wrapUpdate: (node) => {
      wrapUpdate(ctx.selfId, node, ctx.getWaveBits);
    },
    getReactBits: bitManager.getReactBits,
    getWaveBits: bitManager.getWaveBits.bind(null, root),
    getWaveBitsById: bitManager.getWaveBitsById,
    templates: [],
    importMap: importMap2,
    parentId
  };
  const visitor = mergeVisitor(...getBuiltinGenerators(root.type));
  const fnBody = root.body.map((stmt) => {
    const generator = visitor[stmt.type];
    if (generator) {
      return generator(stmt, ctx);
    }
    console.warn(`No generator for stmt: ${stmt.type}`);
    return [];
  }).flat();
  return types2.functionDeclaration(types2.identifier(root.name), root.params, types2.blockStatement(fnBody));
}
function generateSelfId2(level) {
  return types2.identifier(`${CURRENT_COMPONENT}${level ? level : ""}`);
}
var ALREADY_COMPILED = new (WeakSet != null ? WeakSet : Set)();
function transformNode(path2, htmlTags, state, hoist) {
  if (ALREADY_COMPILED.has(path2))
    return false;
  const type = getMacroType(path2);
  if (type) {
    const componentNode = extractFnFromMacro(path2, type);
    let name2 = "";
    if (path2.parentPath.isVariableDeclarator()) {
      const lVal = path2.parentPath.get("id");
      if (lVal.isIdentifier()) {
        name2 = lVal.node.name;
      } else {
        console.error(`${type} macro must be assigned to a variable`);
      }
    }
    const [root, bitManager] = analyze(type, name2, componentNode, {
      htmlTags
    });
    const resultNode = generate(root, bitManager, hoist);
    recordComponentInState(state, name2, root);
    replaceWithComponent(path2, resultNode);
    return true;
  }
  ALREADY_COMPILED.add(path2);
  return false;
}
function plugin_default(api, options) {
  const {
    files = "**/*.{js,ts,jsx,tsx}",
    excludeFiles = "**/{dist,node_modules,lib}/*",
    packageName = "@openinula/next",
    htmlTags: customHtmlTags = (defaultHtmlTags) => defaultHtmlTags,
    attributeMap = defaultAttributeMap
  } = options;
  const htmlTags = typeof customHtmlTags === "function" ? customHtmlTags(defaultHTMLTags) : customHtmlTags.includes("*") ? [.../* @__PURE__ */ new Set([...defaultHTMLTags, ...customHtmlTags])].filter((tag) => tag !== "*") : customHtmlTags;
  register(api);
  return {
    name: "babel-inula-next-core",
    visitor: {
      Program: {
        exit(program, state) {
          if (!fileAllowed(state.filename, toArray(files), toArray(excludeFiles))) {
            program.skip();
            return;
          }
          let transformationHappenedInFile = false;
          const hoistedNodes = [];
          const hoist = (node) => {
            if (Array.isArray(node)) {
              hoistedNodes.push(...node);
            } else {
              hoistedNodes.push(node);
            }
          };
          program.traverse({
            CallExpression(path2) {
              const transformed = transformNode(path2, htmlTags, state, hoist);
              if (transformed) {
                path2.skip();
              }
              transformationHappenedInFile = transformed || transformationHappenedInFile;
            }
          });
          program.node.body.unshift(...hoistedNodes);
          if (transformationHappenedInFile && !options.skipImport) {
            addImport(program.node, getAccessedKeys(), packageName);
          }
        }
      }
    }
  };
}
function replaceWithComponent(path2, resultNode) {
  const variableDeclarationPath = path2.parentPath.parentPath;
  const resultNodeId = resultNode.id;
  if (resultNodeId) {
    const realFuncName = resultNodeId.name;
    resultNodeId.name = path2.scope.generateUid("tmp");
    variableDeclarationPath.replaceWith(resultNode);
    resultNodeId.name = realFuncName;
  } else {
    variableDeclarationPath.replaceWith(resultNode);
  }
}
function recordComponentInState(state, name2, componentNode) {
  const metadata = state.file.metadata;
  if (metadata.components == null) {
    metadata.components = {
      [name2]: componentNode
    };
  } else {
    metadata.components[name2] = componentNode;
  }
}
var ALREADY_COMPILED2 = new (WeakSet != null ? WeakSet : Set)();
function autoNamingPlugin_default(api) {
  register(api);
  return {
    visitor: {
      Program(program) {
        program.traverse({
          FunctionDeclaration(path2) {
            if (ALREADY_COMPILED2.has(path2))
              return;
            const { id } = path2.node;
            const macroNode = getMacroNode(id, path2.node.body, path2.node.params);
            if (macroNode) {
              path2.replaceWith(macroNode);
            }
            ALREADY_COMPILED2.add(path2);
          },
          VariableDeclaration(path2) {
            if (ALREADY_COMPILED2.has(path2))
              return;
            if (path2.node.declarations.length === 1) {
              const { id, init } = path2.node.declarations[0];
              if (types2.isIdentifier(id) && isFnExp(init)) {
                const macroNode = getMacroNode(id, getFnBodyNode(init), init.params);
                if (macroNode) {
                  path2.replaceWith(macroNode);
                }
              }
            }
            ALREADY_COMPILED2.add(path2);
          }
        });
      }
    }
  };
}
function getMacroNode(id, body, params = []) {
  const macroName = getMacroName(id == null ? void 0 : id.name);
  if (macroName) {
    return types2.variableDeclaration("const", [types2.variableDeclarator(id, createMacroNode(body, macroName, params))]);
  }
}
function getMacroName(name2) {
  if (!name2)
    return null;
  if (isUpperCamelCase(name2)) {
    return COMPONENT;
  } else if (isHook(name2)) {
    return HOOK;
  }
  return null;
}
function isUpperCamelCase(str) {
  return /^[A-Z]/.test(str);
}
function isHook(str) {
  return /^use[A-Z]/.test(str) && !builtinHooks.includes(str);
}
function searchNestedProps2(idPath) {
  const nestedProps = [];
  if (idPath.isObjectPattern() || idPath.isArrayPattern()) {
    idPath.traverse({
      Identifier(path2) {
        const parentPath = path2.parentPath;
        if (parentPath.isObjectProperty() && path2.parentKey === "value") {
          nestedProps.push(path2.node.name);
        } else if (parentPath.isArrayPattern() || parentPath.isObjectPattern() || parentPath.isRestElement() || parentPath.isAssignmentPattern() && path2.key === "left") {
          nestedProps.push(path2.node.name);
        }
      }
    });
  }
  return nestedProps;
}
function generateCondNode(branches) {
  const branchNodes = branches.map((branch, idx) => {
    const tag = idx === 0 ? "if" : idx === branches.length - 1 ? "else" : "else-if";
    const conditionAttr = branch.conditions ? [types2.jSXAttribute(types2.jSXIdentifier("cond"), types2.jsxExpressionContainer(branch.conditions))] : [];
    return types2.jsxElement(
      types2.jsxOpeningElement(types2.jSXIdentifier(tag), conditionAttr),
      types2.jsxClosingElement(types2.jSXIdentifier(tag)),
      [types2.jsxElement(types2.jsxOpeningElement(types2.jSXIdentifier(branch.name), [], true), null, [], true)]
    );
  });
  return createFragmentNode(branchNodes);
}
function createFragmentNode(children) {
  return types2.jSXFragment(types2.jSXOpeningFragment(), types2.jSXClosingFragment(), children);
}
function earlyReturnPlugin_default(api) {
  register(api);
  return {
    visitor: {
      CallExpression(path2) {
        if (isCompPath(path2)) {
          const fnPath = extractFnFromMacro(path2, COMPONENT);
          const bodyPath = getFnBodyPath(fnPath);
          const ifStmtIndex = bodyPath.get("body").findIndex((stmt) => stmt.isIfStatement() && hasEarlyReturn(stmt));
          if (ifStmtIndex === -1) {
            return;
          }
          const branches = parseBranches(
            bodyPath.get("body")[ifStmtIndex],
            bodyPath.node.body.slice(ifStmtIndex + 1)
          );
          let i = bodyPath.node.body.length - 1;
          while (i >= ifStmtIndex) {
            bodyPath.get("body")[i].remove();
            i--;
          }
          const branchNodes = branches.map(
            (branch) => types2.variableDeclaration("const", [types2.variableDeclarator(types2.identifier(branch.name), branch.content)])
          );
          bodyPath.pushContainer("body", branchNodes);
          const condNode = generateCondNode(branches);
          bodyPath.pushContainer("body", types2.returnStatement(condNode));
        }
      }
    }
  };
}
function parseBranches(ifStmt, restStmt) {
  const branches = [];
  let next = ifStmt;
  while (next && next.isIfStatement()) {
    const nextConditions = next.node.test;
    branches.push({
      name: genUid(ifStmt.scope, "Branch"),
      conditions: nextConditions,
      content: createMacroNode(types2.blockStatement(getStatements(ifStmt.get("consequent"))), COMPONENT)
    });
    const elseBranch2 = next.get("alternate");
    next = isValidPath2(elseBranch2) ? elseBranch2 : null;
  }
  const elseBranch = next ? next.isBlockStatement() ? next.node.body : [next.node] : [];
  branches.push({
    name: genUid(ifStmt.scope, "Default"),
    content: createMacroNode(types2.blockStatement(elseBranch.concat(restStmt)), COMPONENT)
  });
  return branches;
}
function getStatements(next) {
  return next.isBlockStatement() ? next.node.body : [next.node];
}
function hasEarlyReturn(path2) {
  let hasReturn = false;
  path2.traverse({
    ReturnStatement(path22) {
      if (path22.parentPath.isFunctionDeclaration() || path22.parentPath.isFunctionExpression() || path22.parentPath.isArrowFunctionExpression()) {
        return;
      }
      hasReturn = true;
    }
  });
  return hasReturn;
}
function genUid(scope, name2) {
  let result = name2;
  let i = 1;
  do {
    result = `${name2}_${i}`;
    i++;
  } while (scope.hasBinding(result) || scope.hasGlobal(result) || scope.hasReference(result) || scope.hasGlobal(result));
  const program = scope.getProgramParent();
  program.references[result] = true;
  return result;
}
function forSubComponentPlugin_default(api) {
  register(api);
  return {
    visitor: {
      JSXElement: function(path2) {
        const tagName = path2.node.openingElement.name;
        if (types2.isJSXIdentifier(tagName) && tagName.name === "for") {
          let jsx;
          const children = path2.get("children");
          const expContainer = children.find((child) => child.isJSXExpressionContainer());
          if (!expContainer) {
            return;
          }
          const arrow = expContainer.get("expression");
          if (Array.isArray(arrow)) {
            return;
          }
          if (!arrow.isArrowFunctionExpression()) {
            return;
          }
          const inputs = arrow.get("params");
          let arrowParams = [];
          if (Array.isArray(inputs)) {
            arrowParams = inputs;
          } else {
            arrowParams.push(inputs);
          }
          let params = [];
          arrowParams.forEach((input) => {
            if (input.isIdentifier()) {
              params.push(input.node.name);
            } else if (input.isObjectPattern()) {
              params = params.concat(searchNestedProps2(input));
            }
          });
          const body = arrow.node.body;
          if (types2.isExpression(body)) {
            return;
          }
          if (Array.isArray(body)) {
            return;
          }
          if (body.body.length == 1 && types2.isReturnStatement(body.body[0])) {
            return;
          }
          const id = genUid(path2.scope, "For");
          arrow.node.body = types2.jsxElement(
            types2.jsxOpeningElement(
              types2.jsxIdentifier(id),
              params.map(
                (param) => types2.jsxAttribute(types2.jsxIdentifier(param), types2.jsxExpressionContainer(types2.identifier(param)))
              ),
              true
            ),
            null,
            []
          );
          const func = types2.functionDeclaration(
            types2.identifier(id),
            [
              types2.objectPattern(
                params.map((param) => types2.objectProperty(types2.identifier(param), types2.identifier(param), false, true))
              )
            ],
            body
          );
          let parent = path2.parentPath;
          while (!parent.isReturnStatement()) {
            if (!parent.parentPath) {
              return;
            }
            parent = parent.parentPath;
          }
          parent.insertBefore(func);
        }
      }
    }
  };
}
function mapping2ForPlugin_default(api) {
  register(api);
  return {
    visitor: {
      Program(program) {
        program.traverse({
          CallExpression(path2) {
            callExpressionVisitor(path2, false);
          }
        });
      }
    }
  };
}
function callExpressionVisitor(path2, inner) {
  var _a2, _b, _c;
  if (inner && !path2.parentPath.isArrowFunctionExpression()) {
    return;
  }
  if (!inner && !path2.parentPath.isJSXExpressionContainer()) {
    return;
  }
  if ((_c = (_b = (_a2 = path2.parentPath) == null ? void 0 : _a2.parentPath) == null ? void 0 : _b.parentPath) == null ? void 0 : _c.isJSXOpeningElement()) {
    return;
  }
  const callee = path2.get("callee");
  if (!callee.isMemberExpression()) {
    return;
  }
  const object = callee.get("object");
  const map = callee.get("property");
  if (!map.isIdentifier()) {
    return;
  }
  if (map.node.name !== "map") {
    return;
  }
  const mapArgs = path2.get("arguments");
  if (mapArgs.length !== 1) {
    return;
  }
  const expression = mapArgs[0];
  if (!expression.isExpression()) {
    return;
  }
  const forElement = types2.jsxElement(
    types2.jsxOpeningElement(
      types2.jSXIdentifier("for"),
      [types2.jsxAttribute(types2.jsxIdentifier("each"), types2.jsxExpressionContainer(object.node))],
      false
    ),
    types2.jsxClosingElement(types2.jSXIdentifier("for")),
    [types2.jSXExpressionContainer(expression.node)]
  );
  if (path2.parentPath.isArrowFunctionExpression()) {
    path2.replaceWith(forElement);
  } else {
    path2.parentPath.replaceWith(forElement);
  }
  if (!inner) {
    path2.parentPath.traverse({
      CallExpression(path22) {
        callExpressionVisitor(path22, true);
      }
    });
  }
}
function transformJSXSlice(path2) {
  var _a2, _b, _c, _d, _e;
  if (path2.parentPath.isReturnStatement() && !((_a2 = path2.parentPath.parentPath.parentPath) == null ? void 0 : _a2.isArrowFunctionExpression()) || // handle return statement in component
  path2.parentPath.isJSXElement() || path2.parentPath.isJSXFragment()) {
    return;
  }
  if (path2.parentPath.isArrowFunctionExpression() && ((_b = path2.node.extra) == null ? void 0 : _b.transformJSXSlice)) {
    return;
  }
  let parentPath = path2.parentPath;
  if (parentPath.isReturnStatement() || parentPath.isArrowFunctionExpression()) {
    while (parentPath) {
      if (parentPath.isJSXElement()) {
        const indetifier = (_d = (_c = parentPath.get("openingElement")) == null ? void 0 : _c.node) == null ? void 0 : _d.name;
        if (types2.isJSXIdentifier(indetifier) && indetifier.name === "for") {
          return;
        }
      }
      if (parentPath.isDeclaration()) {
        break;
      }
      parentPath = parentPath.parentPath;
    }
  }
  if (path2.parentPath.isReturnStatement()) {
    const callExpression = path2.parentPath.scope.path.parentPath;
    if (callExpression == null ? void 0 : callExpression.isCallExpression()) {
      const id = callExpression.get("callee");
      if (id.isIdentifier() && ((_e = id.node) == null ? void 0 : _e.name) === COMPONENT) {
        return;
      }
    }
  }
  const sliceCompNode = types2.callExpression(types2.identifier("Component"), [types2.arrowFunctionExpression([], path2.node)]);
  const sliceId = path2.scope.generateUidIdentifier(genName(path2.node));
  sliceId.name = "JSX" + sliceId.name;
  const sliceComp = types2.variableDeclaration("const", [types2.variableDeclarator(sliceId, sliceCompNode)]);
  path2.node.extra = __spreadProps(__spreadValues({}, path2.node.extra), { transformJSXSlice: true });
  if (path2.parentPath.isArrowFunctionExpression()) {
    const block = types2.blockStatement([
      sliceComp,
      types2.returnStatement(types2.callExpression(types2.identifier(importMap2.createCompNode), [sliceId]))
    ]);
    path2.replaceWith(block);
  } else {
    const stmt = path2.getStatementParent();
    if (!stmt) {
      throw new Error("Cannot find the statement parent");
    }
    stmt.insertBefore(sliceComp);
    path2.replaceWith(types2.callExpression(types2.identifier(importMap2.createCompNode), [sliceId]));
  }
}
function genName(node) {
  if (types2.isJSXFragment(node)) {
    return "Fragment";
  }
  const jsxName = node.openingElement.name;
  if (types2.isJSXIdentifier(jsxName)) {
    return jsxName.name;
  } else if (types2.isJSXMemberExpression(jsxName)) {
    let result = jsxName.property.name;
    let current = jsxName.object;
    while (types2.isJSXMemberExpression(current)) {
      result = current.property.name + "_" + result;
      current = current.object;
    }
    result = current.name + "_" + result;
    return result;
  } else {
    return jsxName.name.name;
  }
}
function jsxSlicePlugin_default(api, options) {
  register(api);
  return {
    visitor: {
      Program(program) {
        program.traverse({
          JSXElement(path2) {
            transformJSXSlice(path2);
          },
          JSXFragment(path2) {
            transformJSXSlice(path2);
          }
        });
      }
    }
  };
}
var resetImport = {
  visitor: {
    Program: {
      enter() {
        resetAccessedKeys();
      }
    }
  }
};
function src_default(_, options) {
  var _a2, _b;
  return {
    plugins: [
      (_a2 = import_plugin_syntax_jsx.default.default) != null ? _a2 : import_plugin_syntax_jsx.default,
      [(_b = import_plugin_syntax_typescript.default.default) != null ? _b : import_plugin_syntax_typescript.default, { isTSX: true }],
      resetImport,
      [autoNamingPlugin_default, options],
      [forSubComponentPlugin_default, options],
      [mapping2ForPlugin_default, options],
      [jsxSlicePlugin_default, options],
      [earlyReturnPlugin_default, options],
      [plugin_default, options]
    ]
  };
}

export {
  __require,
  __esm,
  __commonJS,
  __export,
  __toESM,
  __toCommonJS,
  __yieldStar,
  minimatch,
  require_lib,
  src_default
};
